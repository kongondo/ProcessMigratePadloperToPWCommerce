<?php

namespace ProcessWire;

/**
 * Migrate Padloper To PWCommerce: Process.
 *
 * Helper Process Module for migrating Padloper to ProcessWire Commerce.
 * Displays the dashboard for accessing the migration script in the ProcessWire Admin.
 *
 * @author Francis Otieno (Kongondo) <kongondo@gmail.com> kongondo.com
 *
 *
 *
 * ProcessMigratePadloperToPWCommerce for ProcessWire Commerce, ProcessWire
 * Copyright (C) 2025 by Francis Otieno
 * MIT License
 *
 */




class ProcessMigratePadloperToPWCommerce extends Process implements Module {

	private const PAGE_NAME = 'migrate-padloper-to-pwcommerce';
	private const PAGE_TITLE = 'Migrate Padloper to PWCommerce';
	private const MIGRATION_SESSION_NAME = 'pwcommerce-migration';
	private const PADLOPER_SHOP_NAME = 'shop';
	private const PADLOPER_SHOP_REPLACEMENT_NAME = 'shop-2';
	private const PADLOPER_ROOT_PAGE_NAME = 'padloper';
	private const PWCOMMERCE_ROOT_PAGE_NAME = 'pwcommerce';
	private const PWCOMMERCE_TEMPORARY_ROOT_PARENT_NAME = 'temporary-shop';
	private const PADLOPER_PROCESS_MODULE = 'ProcessPadloper';
	private const PWCOMMERCE_PROCESS_MODULE = 'ProcessPWCommerce';
	private const PADLOPER_BACKEND_TEMPLATES_PATH = "padloper/backend/";
	private const PADLOPER_PARTIAL_TEMPLATES_PATH = "padloper/";
	private const PWCOMMERCE_PARTIAL_TEMPLATES_PATH = "pwcommerce/";
	private const PWCOMMERCE_BACKEND_TEMPLATES_PATH = "pwcommerce/backend/";
	private const PADLOPER_CUSTOMER_ROLE_NAME = 'padloper-customer';
	private const PWCOMMERCE_CUSTOMER_ROLE_NAME = 'pwcommerce-customer';

	private $migrationNotices = [];


	public static function getModuleInfo() {

		$moduleInfo =

			[
				'title' => __('Migrate Padloper to ProcessWire Commerce', __FILE__),
				'summary' => __('Module to help migrate Padloper to ProcessWire Commerce', __FILE__),
				'author' => 'Francis Otieno (Kongondo)',
				'version' => "001",
				'href' => 'http://kongondo.com',
				// non-supusers need this permission before ProcessWire will load this module
				'permission' => 'pwcommerce-migrate',
				'singular' => true,
				'requires' => [
					'PHP>=8.2.0',
					'ProcessWire>=3.0.200'
				],
				// Array of permissions that ProcessWire will install (and uninstall) automatically. Permissions should be in the format: array('permission-name' => 'Permission description').
				'permissions' => [
					'pwcommerce-migrate' => __('Permission to use Migrate Padloper to ProcessWire Commerce admin.', __FILE__),
				],

			];



		// ------
		return $moduleInfo;
	}

	public function __construct() {
		parent::__construct();
	}

	public function init() {
		parent::init();
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ EXECUTES  ~~~~~~~~~~~~~~~~~~

	public function execute() {

		$this->headline($this->_("Migrate Padloper to ProcessWire Commerce"));

		$out = "<h3>" .
			$this->_('Important Read')
			. "</h3>";
		$out .= "<p>" .

			$this->_("This tool will migrate your Padloper shop to ProcessWire Commerce shop. ItPlease carefully read and action the following notes!") .

			"</p>";

		$this->_debug();

		// -----
		// NOTES
		$out .= $this->renderNotes();

		// #########

		$errors = $this->runChecks();
		if (!empty($errors)) {
			$out .= "<h3>" .
				$this->_('Error Encountered')
				. "</h3>";
			$out .= "Migration cannot work due to the following errors: {$errors}";
		} else {
			// GOOD TO GO
			// set session
			$this->setMigrationSession();
			// render get started button
			$out .= $this->renderStartMigration();
		}

		//--------------------
		return $out;
	}

	public function executeGetStarted() {
		// TODO DELETE NO LONGER IN USE
		$this->headline($this->_("Get Started"));
		// TODO CHECK IF MIGRATION SESSION IS ON!
		if (empty($this->isMigrationSessionValid())) {
			$error = $this->_('Invalid Migration Session');
			$this->error($error);
			$this->session->redirect($this->page->url);
		};
		// TODO SHOW WHAT'S TO BE DONE + WHAT REQUIRES MANUAL CHANGES, E.G. $padloper and hooks, i.e. PADLOPER::someMethod in ready.php becomes PwCommerce:;someMethod. Note case!
		$out = "<p>GET STARTED!</p>";
		return $out;
	}

	public function executeMigrate() {
		$this->headline($this->_("Run Migration"));
		// TODO CHECK IF MIGRATION SESSION IS ON!
		if (empty($this->isMigrationSessionValid())) {
			$error = $this->_('Invalid Migration Session');
			$this->error($error);
			$this->session->redirect($this->page->url);
		};

		$input = $this->input;
		if ($input->post('migration_run')) {
			bd($input->post, __METHOD__ . ': $input->post - at line #' . __LINE__);
			$this->handleMigrationRun();
		} elseif ($input->post('migration_cancel')) {
			bd($input->post, __METHOD__ . ': $input->post - at line #' . __LINE__);
			$this->handleMigrationCancel();
		}
		// TODO TWO BUTTONS; CANCEL (secondary button)-> HOME; RUN MIGRATION -> SENDS POST; LISTEN TO IT!
		// TODO cache success and errors (WILL SELF-EXPIRE)

		$message = $this->_("Migration is ready to start. Please review and proceed when ready. If the information below does not look right please cancel. Make manual changes if necessary. If happy to proceed please click the run migration button. The migration process might take a while. Please be patient.");


		// show message
		$out = "<p>" .
			$message .

			"</p>" .
			// show migration changes: BEFORE VS AFTER
			$this->renderMigrationChanges() .
			// show RUN AND CANCEL BUTTONs
			$this->renderMigrationButtons();
		return $out;
	}

	public function executeFinishedMigration() {
		$this->headline($this->_("Migration Finished"));
		// TODO SHOW SUCCESS AND/OR ERRORS - SAVED TO CACHE. CACHE WILL SELF EXPIRE
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ VALIDATORS  ~~~~~~~~~~~~~~~~~~

	private function isInstalledModule($class) {
		return $this->wire('modules')->isInstalled($class);
	}

	private function isMigrationSessionValid() {
		$isValidMigrationSession = true;
		// check if session is set
		// check if session set is longer than 1 hour 
		// TODO  time ok?
		$migrationSession = $this->getMigrationSession();
		bd($migrationSession, __METHOD__ . ': $migrationSession - at line #' . __LINE__);


		if (empty($migrationSession)) {
			$isValidMigrationSession = false;
		} elseif (!empty($this->isStaleMigrationSession())) {
			$isValidMigrationSession = false;
		}

		return $isValidMigrationSession;
	}

	private function isStaleMigrationSession() {
		// NOTE TIMESTAMP
		$migrationSession = (int) $this->getMigrationSession();
		$currentTime = time();
		// stale session is one that is more than 1 hour old
		$isStaleSession = $currentTime - $migrationSession > 3600;
		bd($migrationSession, __METHOD__ . ': $migrationSession - at line #' . __LINE__);
		bd($currentTime, __METHOD__ . ': $currentTime - at line #' . __LINE__);
		bd($isStaleSession, __METHOD__ . ': $isStaleSession - at line #' . __LINE__);
		return $isStaleSession;
	}

	private function runChecks() {
		$errorsArray = $this->getErrors();
		$errorsString = "";
		if (!empty($errorsArray)) {
			$errorsString = implode(", ", $errorsArray);
		}
		return $errorsString;
	}

	private function getErrors() {

		$errors = [];

		$padloperClass = 'Padloper';
		$pwCommerceClass = 'PwCommerce';


		// is padloper installed
		if (empty($this->isInstalledModule($padloperClass))) {
			$errors[] = $this->_('Padloper install not found!');
		}
		// is pwcommerce installed
		// IT SHOULDN'T!
		if (!empty($this->isInstalledModule($pwCommerceClass))) {
			$errors[] = $this->_('ProcessWire Commerce install found! Migration not possible');
		}


		bd($errors, __METHOD__ . ': $errors - at line #' . __LINE__);
		return $errors;
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ SESSION  ~~~~~~~~~~~~~~~~~~

	private function setMigrationSession() {
		// TODO IF WE ALREADY HAVE A SESSION AND IT IS NOT MORE THAN 1 HOUR LONG? WE REUSE IT
		if (!empty($this->isStaleMigrationSession())) {
			$this->session->set(self::MIGRATION_SESSION_NAME, time());
		}
	}

	private function getMigrationSession() {
		$migrationSession = $this->session->get(self::MIGRATION_SESSION_NAME);
		return $migrationSession;
	}

	private function removeMigrationSession() {
		$this->session->remove(self::MIGRATION_SESSION_NAME);
	}


	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GETTERS  ~~~~~~~~~~~~~~~~~~

	private function getPadloperPages() {
		// TODO probably not needed! we only need the shop root page then get its children
		// for children in main tree, no need to bother them
	}
	private function getPadloperTemplates(): TemplatesArray {
		// $padloperTemplates = $this->wire('templates')->find("name%=padloper");

		/** @var Templates $templates */
		$templates = $this->wire('templates');

		/** @var TemplatesArray $padloperTemplates */
		$padloperTemplates = $templates->find("name^=padloper");
		return $padloperTemplates;
	}

	private function getPadloperTemplateFiles() {
		// TODO NOT IN USE?
	}

	private function getPadloperBackendTemplatePartials() {
		// TODO ONLY NEEDED FOR 'backend'
		// NOTE - AT THIS POINT, /site/templates/padloper/ has already been renamed to /site/templates/pwcommmerce/ !!!
		// NOTE - what we want is to rename the files inside /site/templates/pwcommerce/backend/
		$backendTemplatePartialsPath = $this->config->paths->templates . self::PADLOPER_BACKEND_TEMPLATES_PATH;

		/** @var WireFileTools $files */
		$files = $this->wire('files');
		$backendTemplatePartialsFiles = $files->find($backendTemplatePartialsPath);
		return $backendTemplatePartialsFiles;
	}

	private function getPWCommerceBackendTemplatePartials() {
		// TODO ONLY NEEDED FOR 'backend'
		// NOTE - AT THIS POINT, /site/templates/padloper/ has already been renamed to /site/templates/pwcommmerce/ !!!
		// NOTE - what we want is to rename the files inside /site/templates/pwcommerce/backend/
		$backendTemplatePartialsPath = $this->config->paths->templates . self::PWCOMMERCE_BACKEND_TEMPLATES_PATH;

		/** @var WireFileTools $files */
		$files = $this->wire('files');
		$backendTemplatePartialsFiles = $files->find($backendTemplatePartialsPath);
		return $backendTemplatePartialsFiles;
	}

	private function getPadloperFields() {
		// $padloperFields = $this->wire('fields')->find("name%=padloper");

		/** @var Fields $fields */
		$fields = $this->wire('fields');

		/** @var FieldsArray $padloperFields */
		$padloperFields = $fields->find("name^=padloper");
		return $padloperFields;
	}

	private function getPadloperCustomFields(): WireArray {

		/** @var Fields $fields */
		$fields = $this->wire('fields');
		$padloperCustomFields = $fields->find("name^=padloper, type%=padloper");
		bdb($padloperCustomFields, __METHOD__ . ': $padloperCustomFields - PADLOPER CUSTOM FIELDS WHOSE TYPE TO CHANGE - POST INSTALL PWCOMMERCE - at line #' . __LINE__);
		return $padloperCustomFields;
	}

	private function getPWCommerceCustomFields(): WireArray {
		/** @var Fields $fields */
		$fields = $this->wire('fields');
		$pwcommerceCustomFields = $fields->find("name^=pwcommerce, type%=pwcommerce");
		bdb($pwcommerceCustomFields, __METHOD__ . ': $pwcommerceCustomFields - PWCOMMERCE CUSTOM FIELDS WHOSE TYPE TO CHANGE TO - POST INSTALL PWCOMMERCE - at line #' . __LINE__);
		return $pwcommerceCustomFields;
	}

	private function getPWCommerceCustomFieldsNames() {
		$padloperCustomFieldsNames = [
			'pwcommerce_customer',
			'pwcommerce_customer_addresses',
			'pwcommerce_discount',
			'pwcommerce_discounts_apply_to',
			'pwcommerce_discounts_eligibility',
			'pwcommerce_download_settings',
			'pwcommerce_notes',
			'pwcommerce_order',
			'pwcommerce_order_customer',
			'pwcommerce_order_discounts',
			'pwcommerce_order_line_item',
			'pwcommerce_product_properties',
			'pwcommerce_product_settings',
			'pwcommerce_product_stock',
			'pwcommerce_runtime_markup',
			'pwcommerce_shipping_fee_settings',
			'pwcommerce_shipping_rate',
			'pwcommerce_tax_overrides',
			'pwcommerce_tax_rates',
		];
		return $padloperCustomFieldsNames;
	}


	private function getPadloperAssetsFolder(): string {
		$padloperAssetsFolderPath = $this->config->paths->templates . self::PADLOPER_PARTIAL_TEMPLATES_PATH;
		bd($padloperAssetsFolderPath, __METHOD__ . ': $padloperAssetsFolderPath - PADLOPER SITE ASSETS FOLDER TO RENAME - at line #' . __LINE__);
		return $padloperAssetsFolderPath;
	}

	private function getPadloperInstallSettings() {
		/** @var Modules $modules */
		$modules = $this->wire('modules');
		$configs = $modules->getConfig(self::PADLOPER_PROCESS_MODULE);
		return $configs;
	}

	private function getProcessPadloperShopPage() {
		// ProcessPadloper page
		// i.e. /admin/shop/
		$parent = $this->wire('pages')->get($this->wire('config')->adminRootPageID);
		$shopPage = $this->wire('pages')->get("parent=$parent, template=admin, include=all, name=" . self::PADLOPER_SHOP_NAME);
		return $shopPage;
	}

	private function getPadloperRootPage() {
		// root page of all padloper pages
		// child of the ProcessPadloper page
		// i.e. /admin/shop/padloper/
		$parent = $this->getProcessPadloperShopPage();
		$rootPage = $this->wire('pages')->get("parent=$parent, template=padloper, include=all, name=" . self::PADLOPER_ROOT_PAGE_NAME);
		return $rootPage;
	}

	private function getPadloperTemporaryRootParent() {
		// TEMPORARY root page of all padloper pages
		// child of /admin/temporary-shop/
		$parent = $this->wire('pages')->get($this->wire('config')->adminRootPageID);
		$temporaryRootParent = $this->wire('pages')->get("parent=$parent, template=admin, include=all, name=" . self::PWCOMMERCE_TEMPORARY_ROOT_PARENT_NAME);
		return $temporaryRootParent;
	}

	private function getPWCommerceProcessPage() {
		// TODO CHANGE CONSTANT BELOW!
		/** @var Modules $modules */
		$modules = $this->wire('modules');
		/** @var Process $process */
		$process = $modules->get(self::PADLOPER_PROCESS_MODULE);
		// PWCOMMERCE_PROCESS_MODULE
		$processPage = $process->getProcessPage();
		return $processPage;
	}

	private function getPadloperCustomerRole() {
		/** @var Roles $roles */
		$roles = $this->wire('roles');
		$customerRole = $roles->get(self::PADLOPER_CUSTOMER_ROLE_NAME);
		return $customerRole;
	}

	private function getUninstallPadloperModulesNames() {
		// NOTE: in order of uninstall
		$padloperModules = [
			'PadloperHooks',
			'Padloper',
			'ProcessPadloper',
		];
		return $padloperModules;
	}

	private function getClassShortName($object) {
		$shortName = (new \ReflectionClass($object))->getShortName();
		return $shortName;
	}



	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ NOTES  ~~~~~~~~~~~~~~~~~~

	private function renderNotes() {
		$out = "<ol>";
		foreach ($this->getNotes() as $note) {
			$out .= "<li>{$note}</li>";
		}
		$out .= "</ol>";
		return $out;
	}

	private function getNotes() {
		$notes = [
			$this->_('Usage of this tool is at your own risk.'),
			$this->_('Create a whole backup of your site before getting started.'),
			$this->_('DO NOT MANUALLY UNINSTALL Padloper! This tool will do that for you. It will also uninstall all related Modules and Fields and preserve existing fields data.'),
			$this->_('DO NOT MANUALLY INSTALL ProcessWire Commerce! This tool will do that for you. It will also install related Modules and Fields and import existing fields data.'),
			$this->_('Preferably, test on test server.'),
			$this->_('If the tests pass, it is still advisable to create a duplicate of your production site, run the migration there, create a database dump of the migrated site and use that to update your real production site.'),
			$this->_('Do not uninstall Padloper until after this script has finished successfully. Doing so will delete all your Padloper pages!'),
		];
		return $notes;
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MISC  ~~~~~~~~~~~~~~~~~~

	private function renderStartMigration() {

		$out = "<h3>" .
			$this->_('Get Started')
			. "</h3>";

		$out .= "<p>" .

			$this->_("Click the button to get started with the migration.") .
			"</p>";


		$href = $this->page->url . "migrate/";
		bd($href, __METHOD__ . ': $href - at line #' . __LINE__);
		$options = [
			'name' => 'pwmigrate_get_started',
			'label' => $this->_('Get Started'),
			'type' => 'button',
			'href' => $href,
		];
		$field = $this->getButton($options);

		$out .= $field->render();
		return $out;
	}

	private function renderMigrationChanges() {

		// automated changes
		$out = "<h3>" .
			$this->_('Automated Changes')
			. "</h3>";
		$out .= '<p>' .

			$this->_('Please note that Templates, Fields, Roles, and Assets will be RENAMED, Fieldtypes will be REASSIGNED, Pages will be REPARENTED and settings will be REAPPLIED.') .

			'</p>';

		$out .= $this->renderMigrationAutomatedChangesList();

		// other automated changes

				$out .= "<h3>" .
			$this->_('Other Automated Changes')
			. "</h3>";
		$out .= '<p>' .

			$this->_("During the install, the migration tool will uninstall 'Padloper' and related modules without loss of data. It will subsequently install 'ProcessWire Commerce'.") .

			'</p>';


		// manual changes
		$out .= "<h3>" .
			$this->_('Required Manual Changes')
			. "</h3>";

		$out .= $this->renderMigrationRequiredManualChanges();
		return $out;
	}

	private function renderMigrationAutomatedChangesList() {

		$items = [
			'before',
			'after',
			// not in use for now!
			// 'notes',
		];

		$colspan = count($items);


		$allTasksItems = $this->getMigrationChangesTasksItems();
		bd($allTasksItems, __METHOD__ . ': $allTasksItems - at line #' . __LINE__);

		$out =
			"<table id='migrate_padloper_pwcommerce'>" .

			"<thead>" .
			"<tr>" .
			"<th>" . $this->_('Before') . "</th>" .
			"<th>" . $this->_('After') . "</th>" .
			// "<th>" . $this->_('Notes') . "</th>" .
			"</tr>" .
			"</thead>" .
			"<tbody>";

		foreach ($this->getMigrationChangesTasksList() as $task => $taskHeading) {


			$taskItems = $allTasksItems[$task];

			// task heading
			$out .=
				"<tr>
				<th colspan='{$colspan}'>{$taskHeading}</th>			
				</tr>";
			// task items
			$out .= "<tr>";
			// foreach ($tasksItems[$key] as $item) {
			foreach ($items as $item) {
				if ($item === 'before') {
					// BEFORE
					$taskItemsList = $this->renderSingleTaskItems($task, $taskItems);
				} else {
					// AFTER
					$taskItemsList = $this->renderSingleTaskItems($task, $taskItems, false);
				}
				// populate the TD
				$out .= "<td>{$taskItemsList}</td>";
			}
			$out .= "</tr>";
		}




		$out .=
			"<tbody>" .
			"</table>";

		return $out;
	}

	private function renderMigrationRequiredManualChanges() {

		$changesNotice = $this->_('Please note that you will need to make some changes to your template files. These are outlined below.');

		$changesTemplateFiles = $this->_("Template Files: All instances of '\$padloper' should be replaced by '\$pwcommerce'. For instance '\$padloper->getCart()' should become '\$pwcommerce->getCart()'.");

		$changesHooks = $this->_("Hooks: Your hooks, e.g. in ready.php should be renamed as follows: All instances of 'Padloper::someHookedMethod' should become 'PwCommerce::someHookedMethod'. Please note the spelling is case-sensitive.");
		$out =

			"<p>" .

			$changesNotice .
			"</p>" .

			"<ol>" .
			"<li>" . $changesTemplateFiles . "</li>" .
			"<li>" . $changesHooks . "</li>" .

			"</ol>";

		return $out;
	}

	private function renderSingleTaskItems($task, $taskItems, $isBefore = true) {
		$out = "<ol>";

		if ($task === 'roles') {


			bd($taskItems, __METHOD__ . ': $taskItems - at line #' . __LINE__);
			bd($task, __METHOD__ . ': $task - at line #' . __LINE__);
		}


		foreach ($taskItems as $taskItem) {

			if ($task === 'fieldtypes') {
				// if fieldtypes, we get the 'type'
				$itemStr = $this->getClassShortName($taskItem->type);
			} elseif ($task === 'pages') {
				// path if pages
				$itemStr = $taskItem->path;
			} elseif ($task === 'assets') {
				$itemStr = $taskItem;
			} elseif ($task === 'install_settings') {
				// json if configs
				$itemStr = json_encode($taskItem, JSON_PRETTY_PRINT);
			} else {
				// use name for templates, fields and roles
				$itemStr = $taskItem->name;
			}

			// Padloper vs PWCommerce
			$itemStr = $isBefore ? $itemStr : $this->getMigrationChangeRename($itemStr);
			$out .= "<li>{$itemStr}</li>";
		}
		$out .= "</ol>";
		return $out;
	}

	private function renderMigrationButtons() {

		/** @var Modules $modules */
		$modules = $this->wire('modules');

		// migration form
		/** @var InputfieldForm $form */
		$form = $modules->get('InputfieldForm');

		// run migration button
		$options = [
			'type' => 'submit',
			'label' => 'Run Migration',
			'name' => 'migration_run',
		];

		$field = $this->getButton($options);
		$form->add($field);

		// cancel button
		$options = [
			'is_secondary' => true,
			'type' => 'submit',
			'label' => 'Cancel Migration',
			'name' => 'migration_cancel',
		];

		$field = $this->getButton($options);
		$form->add($field);

		$out = $form->render();

		return $out;
	}

	private function getButton($options) {

		/** @var InputfieldButton $field */
		$field = $this->wire('modules')->get('InputfieldButton');
		$type = !empty($options['type']) ? $options['type'] : 'button';

		$field->attr([
			'name' => $options['name'],
			'value' => $options['label'],
			'type' => $type,

		]);

		if (!empty($options['href'])) {
			$field->attr('href', $options['href']);
		}

		if (!empty($options['is_secondary'])) {
			$field->setSecondary();
		}

		return $field;
	}

	private function getMigrationChangesTasksList() {
		$tasksList = [
			'templates' => $this->_('Templates'),
			'fields' => $this->_('Fields'),
			'fieldtypes' => $this->_('Fieldtypes'),
			'pages' => $this->_('Pages'),
			'roles' => $this->_('Roles'),
			'assets' => $this->_('Assets'),
			'install_settings' => $this->_('Install Settings'),
		];

		return $tasksList;
	}

	private function getMigrationChangesTasksItems() {
		// assets folder
		$assets = [
			$this->getPadloperAssetsFolder()
		];
		// /site/templates/padloper/backend/*.* partials
		$assets = array_merge($assets,  $this->getPadloperBackendTemplatePartials());

		$subTasksList = [
			'templates' => $this->getPadloperTemplates(),
			'fields' => $this->getPadloperFields(),
			'fieldtypes' => $this->getPadloperCustomFields(),
			'pages' => [$this->getPadloperRootPage()],
			'roles' => [$this->getPadloperCustomerRole()],
			'assets' => $assets,
			'install_settings' => $this->getPadloperInstallSettings(),
		];

		return $subTasksList;
	}

	private function getMigrationChangesBeforeItems($task) {
		$allTasksItems = $this->getMigrationChangesTasksItems();
		$taskItems = $allTasksItems[$task];
		return $taskItems;
	}

	private function getMigrationChangeRename($item) {
		$search = ['Padloper', 'padloper', 'PADLOPER'];
		$replace = ['PWCommerce', 'pwcommerce', 'PWCOMMERCE'];
		$renamedItem = str_replace($search, $replace, $item);
		return $renamedItem;
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MIGRATORS  ~~~~~~~~~~~~~~~~~~

	private function actionRunMigration() {
		// TODO THIS WILL RUN THE MIGRATION TOOLS BELOW, IN A PARTICULAR ORDER
		// TODO EACH ACTION SHOULD 'RECORD' SUCCESS OR ERROR
		// IN FINAL METHOD, WE SAVE THOSE TO CACHE
	}

	private function actionMigratePages() {
		// TODO DELETE IF NOT IN USE
	}


	private function actionMigrateTemplates() {
		// TODO ALSO NEED TO RENAME LABELS!
		$padloperTemplates = $this->getPadloperTemplates();
		bdb($padloperTemplates, __METHOD__ . ': $padloperTemplates - at line #' . __LINE__);
		if (!empty($padloperTemplates->count())) {
			// TODO MAYBE IN RUN CHECKS?
			/** @var Template $template */
			foreach ($padloperTemplates as $template) {
				// bd($template, __METHOD__ . ': $template - FOR RENAMED TEMPLATE - at line #' . __LINE__);
				$name = str_replace("padloper", "pwcommerce", $template->name);
				$label = str_replace("Padloper", "PWCommerce", $template->label);

				$description = null;

				if (!empty($template->description)) {
					$description = str_replace("padloper", "pwcommerce", $template->description);
				}



				bd($name, __METHOD__ . ': $name - FOR RENAMED TEMPLATE - at line #' . __LINE__);
				bd($label, __METHOD__ . ': $label - FOR RENAMED TEMPLATE - at line #' . __LINE__);
				bd($description, __METHOD__ . ': $description - FOR RENAMED TEMPLATE - at line #' . __LINE__);
				// $this->wire('templates')->rename($template, $name);
				$template->label = $label;
				if (!empty($description)) {
					$template->description = $description;
				}
				// $this->wire('template')->save($template);
			}
		}
	}
	private function actionMigrateTemplateFiles() {
		// TODO not needed?
	}

	private function actionMigrateBackendTemplatePartials() {
		// NOTE - AT THIS POINT, /site/templates/padloper/ has already been renamed to /site/templates/pwcommmerce/ !!!
		// NOTE - what we want is to rename the files inside /site/templates/pwcommerce/backend/
		$backendTemplatePartialsFiles = $this->getPWCommerceBackendTemplatePartials();
		bdb($backendTemplatePartialsFiles, __METHOD__ . ': $backendTemplatePartialsFiles - at line #' . __LINE__);
		/** @var WireFileTools $files */
		$files = $this->wire('files');
		if (!empty($backendTemplatePartialsFiles)) {
			// TODO RENAME THEM
			foreach ($backendTemplatePartialsFiles as $oldName) {
				$newName = str_replace("padloper", "pwcommerce", $oldName);
				// TODO CATCH ERRORS?
				// $bool = $files->rename($oldName,  $newName);
				bd($oldName, __METHOD__ . ': $oldName - at line #' . __LINE__);
				bd($newName, __METHOD__ . ': $newName - at line #' . __LINE__);
				// bd($bool, __METHOD__ . ': $bool - at line #' . __LINE__);
			}
		}
	}

	private function actionMigrateFields() {
		$padloperFields = $this->getPadloperFields();
		bdb($padloperFields, __METHOD__ . ': $padloperFields - at line #' . __LINE__);
		if (!empty($padloperFields->count())) {
			// TODO MAYBE IN RUN CHECKS?
			/** @var Field $field */
			foreach ($padloperFields as $field) {
				$name = str_replace("padloper", "pwcommerce", $field->name);
				$label = str_replace("Padloper", "PWCommerce", $field->label);


				$description = null;

				if (!empty($field->description)) {
					$description = str_replace("padloper", "pwcommerce", $field->description);
				}


				// bd($name, __METHOD__ . ': $name - FOR RENAMED FIELD - at line #' . __LINE__);
				// bd($label, __METHOD__ . ': $label - FOR RENAMED FIELD - at line #' . __LINE__);
				// bd($description, __METHOD__ . ': $description - FOR RENAMED FIELD - at line #' . __LINE__);
				// bd($field, __METHOD__ . ': $field - FOR RENAMED FIELD - at line #' . __LINE__);
				$field->name = $name;
				$field->label = $label;
				if (!empty($description)) {
					$field->description = $description;
				}
				// $this->wire('fields')->save($field);
			}
		}
	}

	private function actionMigrateCustomFieldsTypes() {

		// the padlpoper custom fields (e.g. 'padloper_customer') whose TYPES need changing to PWCommerce ones
		// NOTE - we want to retain the fields (db records) themselves
		$padloperCustomFields = $this->getPadloperCustomFields();
		// the PW commerce whose objects we will use to change the types of field above
		// we use $field->name to match them
		$pwcommerceCustomFields = $this->getPWCommerceCustomFields();


		bdb($padloperCustomFields, __METHOD__ . ': $padloperCustomFields - at line #' . __LINE__);
		bdb($pwcommerceCustomFields, __METHOD__ . ': $pwcommerceCustomFields - at line #' . __LINE__);



		// TODO - WILL WE HAVE INSTALLED THE CUSTOM FIELDS FIRST?
		// E.G. IF INSTALL HAS padloper_notes, we install pwcommerce_notes???

		if (!empty($padloperCustomFields->count())) {
			/** @var Field $padloperCustomField */
			foreach ($padloperCustomFields as $padloperCustomField) {
				// GET THE SHORTNAME OF THE CLASS OF THE CURRENT FIELDTYPE
				// e.g. 'FieldtypePadloperNotes'
				$padloperCustomFieldTypeClass = $this->getClassShortName($padloperCustomField->type);

				$pwcommerceCustomFieldTypeClass = str_replace("Padloper", "PWCommerce", $padloperCustomFieldTypeClass);
				bd($padloperCustomFieldTypeClass, __METHOD__ . ': $padloperCustomFieldTypeClass - at line #' . __LINE__);
				bd($pwcommerceCustomFieldTypeClass, __METHOD__ . ': $pwcommerceCustomFieldTypeClass - at line #' . __LINE__);
				// install the PWCommerce Field
				// TODO CONFIRM IT INSTALLS INPUTFIELD ALSO
				$module = $this->actionMigrateInstallModule($pwcommerceCustomFieldTypeClass);
				if (empty($module)) {
					// TODO ERROR CATCH
				} else {

					// SET FIELDTYPE
					// $field = $field->setFieldtype($type);
					// type	string, Fieldtype Type should be either a Fieldtype object or the string name of a Fieldtype object.
					// $field->type


					// UNINSTALL PADLOPER CUSTOM FIELDTYPE
					// TODO OK HERE OR ALWAYS?
					// HERE OTHERWISE WILL 'HANG'?
				}
			}
		}
	}

	private function actionMigratePadloperAssetsFolder() {
		$padloperAssetsFolder = $this->getPadloperAssetsFolder();
		$newName = str_replace("padloper", "pwcommerce", $padloperAssetsFolder);
		/** @var WireFileTools $files */
		$files = $this->wire('files');


		$isExistAssetsFolder = $files->exists($padloperAssetsFolder);

		if (!empty($isExistAssetsFolder)) {
			// TODO CATCH ERRORS?
			// $bool = $files->rename($padloperAssetsFolder,  $newName);
		}


		bd($padloperAssetsFolder, __METHOD__ . ': $padloperAssetsFolder - at line #' . __LINE__);
		bd($isExistAssetsFolder, __METHOD__ . ': $isExistAssetsFolder - at line #' . __LINE__);
		bd($newName, __METHOD__ . ': $newName - at line #' . __LINE__);
	}

	private function actionMigrateRootPage() {
		$rootPage = $this->getPadloperRootPage();
		bd($rootPage, __METHOD__ . ': $rootPage - at line #' . __LINE__);
		// NOTE run after ProcessWire Commerce has been installed in order to get its Process Page!
		// NOTE at this point, these has been moved to a temporary parent
		// in order to circumvent the 'shop' name issue, i.e. needed by both Padloper and PW Commerce
		$rootPage = $this->getPadloperRootPage();
		$rootParent = $this->getPWCommerceProcessPage();
		bd($rootPage, __METHOD__ . ': $rootPage - at line #' . __LINE__);
		bd($rootParent, __METHOD__ . ': $rootParent - at line #' . __LINE__);
		$rootPage->of(false);
		$rootPage->parent = $rootParent;
		$rootPage->title = 'PWCommerce';
		$rootPage->name = self::PWCOMMERCE_ROOT_PAGE_NAME;
		// $rootPage->save();
	}

	private function actionMigrateTemporaryRootPage() {
		$rootPage = $this->getPadloperRootPage();
		$temporaryRootParent = $this->getPadloperTemporaryRootParent();
		bd($rootPage, __METHOD__ . ': $rootPage - at line #' . __LINE__);
		bd($temporaryRootParent, __METHOD__ . ': $temporaryRootParent - at line #' . __LINE__);
		// NOTE run after ProcessWire Commerce has been installed in order to get its Process Page!
		// NOTE at this point, these has been moved to a temporary parent
		// in order to circumvent the 'shop' name issue, i.e. needed by both Padloper and PW Commerce
		$rootPage->of(false);
		$rootPage->parent = $temporaryRootParent;
		// $rootPage->save();
	}

	private function actionMigrateCreateTemporaryRootParent() {
		// TEMPORARY ROOT PARENT to hold the children of PADLOPER /admin/shop/, i.e. the Padloper Process Page
		// this is so that we can uninstall ProcessPadloper without deleting shop pages!
		$page = new Page();
		$page->template = 'admin';
		$page->parent = $this->wire('pages')->get($this->wire('config')->adminRootPageID);
		$page->title = 'Temporary Shop';
		$page->name = self::PWCOMMERCE_TEMPORARY_ROOT_PARENT_NAME;
		// $page->save();
	}

	private function actionMigrateCustomerRole() {
		$customerRole = $this->getPadloperCustomerRole();
		bd($customerRole, __METHOD__ . ': $customerRole - at line #' . __LINE__);
		$customerRole->of(false);
		$customerRole->name = self::PWCOMMERCE_CUSTOMER_ROLE_NAME;
		// $customerRole->save();
		bd($customerRole, __METHOD__ . ': $customerRole - AFTER RENAME - at line #' . __LINE__);
	}

	private function actionMigrateUninstallPadloperModules() {

		$padloperModulesNames = $this->getUninstallPadloperModulesNames();
		bd($padloperModulesNames, __METHOD__ . ': $padloperModulesNames - at line #' . __LINE__);

		/** @var Modules $modules */
		$modules = $this->wire('modules');
		foreach ($padloperModulesNames as $padloperModuleName) {
			// $bool = $this->actionMigrateUninstallModule($padloperModuleName);
		}
	}

	private function actionMigrateUninstallPadloperCustomFields() {

		$padloperCustomFields = $this->getPadloperCustomFields();
		bd($padloperCustomFields, __METHOD__ . ': $padloperCustomFields - at line #' . __LINE__);

		/** @var Field $padloperCustomField */
		foreach ($padloperCustomFields as $padloperCustomField) {
			// TODO DOES THIS UNINSTALL ITS INPUTFIELD AS WELL?
			$padloperCustomFieldTypeClass = $this->getClassShortName($padloperCustomField->type);
			// $bool = $this->actionMigrateUninstallModule($padloperCustomField);
			if (empty($bool)) {
				// TODO NOT UNINSTALLED
			}
		}
	}


	private function actionMigrateInstallModule($class) {
		bd($class, __METHOD__ . ': $class - at line #' . __LINE__);
		/** @var Modules $modules */
		$modules = $this->wire('modules');
		// TODO DELETE AFTER DEBUG/WHEN READY
		$module = false;
		//$module = $modules->install($class);
		return $module;
	}

	private function actionMigrateUninstallModule($class) {
		bd($class, __METHOD__ . ': $class - at line #' . __LINE__);
		/** @var Modules $modules */
		$modules = $this->wire('modules');
		// TODO DELETE AFTER DEBUG/WHEN READY
		$isUninstalled = false;
		// $isUninstalled = $modules->uninstall($class);
		return $isUninstalled;
	}


	private function actionMigrateInstallSettings() {
		$installConfigs = $this->getPadloperInstallSettings();
		bdb($installConfigs, __METHOD__ . ': $installConfigs - PROCESS PADLOPER INSTALL SETTINGS TO IMPORT - at line #' . __LINE__);
		$importInstallConfigs = [];
		foreach ($installConfigs as $key => $value) {
			$renamedKey = str_replace("padloper", "pwcommerce", $key);
			$importInstallConfigs[$renamedKey] = $value;
		}
		bdb($importInstallConfigs, __METHOD__ . ': $importInstallConfigs - PROCESS PADLOPER RENAMED INSTALL SETTINGS TO IMPORT - at line #' . __LINE__);

		// TODO WE NEED TO RETRIEVE THEM BEFORE WE UNINSTALL PADLOPER BUT AFTER WE INSTALL PROCESSWIRE COMMERCE!
		// SO SAVE TO CACHE?
		// $this->cachePadloperInstallSettings($importInstallConfigs);
		// save them
		// $this->savePadloperInstallSettings($importInstallConfigs);
	}

	private function savePadloperInstallSettings($data) {
		/** @var Modules $modules */
		$modules = $this->wire('modules');
		$configs = $modules->saveConfig(self::PADLOPER_PROCESS_MODULE, $data);
		return $configs;
	}
	private function cachePadloperInstallSettings($data) {
		/** @var WireCache $cache */
		$cache = $this->wire('cache');
		$cache->save(self::PADLOPER_PROCESS_MODULE, $data);
	}

	private function actionCacheMigrationNotices() {
	}


	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CACHE  ~~~~~~~~~~~~~~~~~~

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FORM HANDLERS  ~~~~~~~~~~~~~~~~~~

	private function handleMigrationCancel() {
		// remove migration session
		$this->removeMigrationSession();
		// show warning
		$warning = $this->_('Migration session cancelled');
		$this->warning($warning);
		// redirect to home
		$this->session->redirect($this->page->url);
	}

	private function handleMigrationRun() {
		// TODO RUN ACTION MIGRATION
		exit('got the post TO RUN!');
	}


	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ INSTALL  ~~~~~~~~~~~~~~~~~~

	public function ___install() {

		// check if there is another page in admin with the name 'shop'. If so, abort installation
		if ($this->installerOurModulePageAlreadyExists()) {
			throw new WireException($this->_("Process PWCommerce: Installation aborted. A page with the name 'shop' already exists. This module needs that name. Please fix this then retry."));
		}

		// PWCOMMERCE PROCESS MODULE ADMIN PAGE
		// create the page for this module (ProcessMigratePadloperToPWCommerce)
		// it needs to use the template admin and it needs to have this module as its process
		$page = new Page();
		$page->template = 'admin';
		$page->parent = $this->wire('pages')->get($this->wire('config')->adminRootPageID);
		$page->title = self::PAGE_TITLE;
		$page->name = self::PAGE_NAME;
		$page->process = $this;
		$page->save();
		// -------------



		// -------
		// tell the user we created the page for this module
		$this->message("Process MigratePadloperToPWCommerce: Created page {$page->path}");
	}

	public function ___uninstall() {
		// find and delete the page we installed, locating it by the process field (which has the module ID)
		// it would probably be sufficient just to locate by name, but this is just to be extra sure.
		$moduleID = $this->wire('modules')->getModuleID($this);
		$page = $this->wire('pages')->get("template=admin, process=$moduleID, name=" . self::PAGE_NAME);
		// $page = $this->wire('pages')->get('template=admin, name='.self::PAGE_NAME);
		if ($page->id) {
			// if we found the page, let the user know and delete it
			$this->message($this->_('Process MigratePadloperToPWCommerce: Deleted page ') . $page->path);
			// @note: delete any child pages as well
			$this->wire('pages')->delete($page, true);
		}
	}

	private function installerOurModulePageAlreadyExists() {
		$isPageExist = false;
		// check if our process module's page already exists in Admin
		$parent = $this->wire('pages')->get($this->wire('config')->adminRootPageID);
		$page = $this->wire('pages')->get("parent=$parent, template=admin, include=all, name=" . self::PAGE_NAME);
		if ($page->id && $page->id > 0) {
			$isPageExist = true;
		}

		return $isPageExist;
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DEBUG  ~~~~~~~~~~~~~~~~~~

	private function _debug() {
		// TEST GET PADLOPER PROCESS PAGE
		// $processPadloperShopPage = $this->getProcessPadloperShopPage();
		// bd($processPadloperShopPage, __METHOD__ . ': $processPadloperShopPage - PADLOPER PROCESS PAGE - at line #' . __LINE__);

		// TEST GET PADLOPER SHOP ROOT PAGE
		// $padloperRootPage = $this->getPadloperRootPage();
		// bd($padloperRootPage, __METHOD__ . ': $padloperRootPage - PADLOPER SHOP ROOT PAGE - at line #' . __LINE__);

		// TEST GET PADLOPER TEMPLATES TO RENAME
		// $padloperTemplates = $this->getPadloperTemplates();
		// bdb($padloperTemplates, __METHOD__ . ': $padloperTemplates - PADLOPER TEMPLATES TO RENAME - at line #' . __LINE__);

		// TEST RENAME PADLOPER TEMPLATES
		// $this->actionMigrateTemplates();

		// TEST GET PADLOPER FIELDS TO RENAME
		// $padloperFields = $this->getPadloperFields();
		// bdb($padloperFields, __METHOD__ . ': $padloperFields - PADLOPER FIELDS TO RENAME - at line #' . __LINE__);

		// TEST RENAME PADLOPER FIELDS
		// $this->actionMigrateFields();

		// TEST GET PROCESS PADLOPER INSTALL SETTINGS TO IMPORT
		// $installConfigs = $this->getPadloperInstallSettings();
		// bdb($installConfigs, __METHOD__ . ': $installConfigs - PROCESS PADLOPER INSTALL SETTINGS TO IMPORT - at line #' . __LINE__);


		// TODO ALSO NEED TO CHANGE THE FIELDS TYPES IF THEY ARE CUSTOM PADLOPER ONES!
		// TODO NEEDS TO BE DONE AFTER PWCOMMERCE IS INSTALLED + ITS FIELDS ARE INSTALLED
		// TODO BUT HOW WILL WE KNOW THE FIELDS TO INSTALL? MAYBE THEY SHOULD MANUALLY INSTALL PW COMMERCE? I.E. INCLUDING STAGE 2?
		// WE CAN CHECK FIELDS TO INSTALL USING CONFIGS BUT THAT IS TEDIOUS?!


		// TEST GET PADLOPER CUSTOM FIELDS
		// $padloperCustomFields = $this->getPadloperCustomFields();
		// $pwcommerceCustomFields = $this->getPWCommerceCustomFields();
		// bdb($padloperCustomFields, __METHOD__ . ': $padloperCustomFields -  PADLOPER CUSTOM FIELDS WHOSE TYPES TO CHANGE - at line #' . __LINE__);
		// bdb($pwcommerceCustomFields, __METHOD__ . ': $pwcommerceCustomFields -  PWCOMMERCE CUSTOM FIELDS WHOSE TYPES TO USE FOR CHANGE - at line #' . __LINE__);


		// TEST CHANGE TYPE OF PADLOPER CUSTOM FIELDS
		// $this->actionMigrateCustomFieldsTypes();


		// TEST IMPORT PROCESS PADLOPER INSTALL SETTINGS
		// $this->actionMigrateInstallSettings();

		// TEST GET PADLOPER SITE ASSETS FOLDER TO RENAME
		// $padloperAssetsFolder = $this->getPadloperAssetsFolder();
		// bd($padloperAssetsFolder, __METHOD__ . ': $padloperAssetsFolder - PADLOPER SITE ASSETS FOLDER TO RENAME - at line #' . __LINE__);

		// TEST RENAME PADLOPER SITE ASSETS FOLDER
		// $this->actionMigratePadloperAssetsFolder();


		// TEST GET PADLOPER BACKEND TEMPLATE PARTIALS TO RENAME
		// $backendTemplatePartialsFiles = $this->getPadloperBackendTemplatePartials();
		// bd($backendTemplatePartialsFiles, __METHOD__ . ': $backendTemplatePartialsFiles - PADLOPER BACKEND TEMPLATE PARTIALS TO RENAME - at line #' . __LINE__);

		// TEST RENAME PADLOPER BACKEND TEMPLATE PARTIALS
		// $this->actionMigrateBackendTemplatePartials();

		// TEST GET PADLOPER MODULES NAMES TO UNINSTALL
		// $padloperModules = $this->getUninstallPadloperModulesNames();
		// bd($padloperModules, __METHOD__ . ': $padloperModules - PADLOPER MODULES NAMES TO UNINSTALL - at line #' . __LINE__);

		// TEST UNINSTALL PADLOPER MODULES
		// $this->actionMigrateUninstallPadloperModules();
	}
}
