<?php

namespace ProcessWire;

/**
 * Migrate Padloper To PWCommerce: Process.
 *
 * Helper Process Module for migrating Padloper to ProcessWire Commerce.
 * Displays the dashboard for accessing the migration script in the ProcessWire Admin.
 *
 * @author Francis Otieno (Kongondo) <kongondo@gmail.com> kongondo.com
 *
 *
 * ProcessMigratePadloperToPWCommerce for ProcessWire Commerce, ProcessWire
 * Copyright (C) 2025 by Francis Otieno
 * MIT License
 *
 */




class ProcessMigratePadloperToPWCommerce extends Process implements Module {

	private const PAGE_NAME = 'migrate-padloper-to-pwcommerce';
	private const PAGE_TITLE = 'Migrate Padloper to PWCommerce';
	private const MIGRATION_SESSION_NAME = 'pwcommerce-migration';
	private const PADLOPER_SHOP_NAME = 'shop';
	private const PADLOPER_ROOT_PAGE_NAME = 'padloper';
	private const PWCOMMERCE_ROOT_PAGE_NAME = 'pwcommerce';
	private const PWCOMMERCE_TEMPORARY_ROOT_PARENT_NAME = 'temporary-shop';
	private const PADLOPER_PROCESS_MODULE = 'ProcessPadloper';
	private const PWCOMMERCE_PROCESS_MODULE = 'ProcessPWCommerce';
	private const PWCOMMERCE_IMPORTED_INSTALL_SETTINGS_CACHE_NAME = 'pwcommerce-imported-settings';
	private const PWCOMMERCE_MIGRATION_NOTICES_CACHE_NAME = 'pwcommerce-migration-notices';
	private const PADLOPER_BACKEND_TEMPLATES_PATH = "padloper/backend/";
	private const PADLOPER_PARTIAL_TEMPLATES_PATH = "padloper/";
	private const PWCOMMERCE_PARTIAL_TEMPLATES_PATH = "pwcommerce/";
	private const PWCOMMERCE_BACKEND_TEMPLATES_PATH = "pwcommerce/backend/";
	private const PADLOPER_CUSTOMER_ROLE_NAME = 'padloper-customer';
	private const PWCOMMERCE_CUSTOMER_ROLE_NAME = 'pwcommerce-customer';

	private $migrationNotices = [];
	private $installedPadloperCustomerFieldsNames = [];


	public static function getModuleInfo() {

		$moduleInfo =

			[
				'title' => __('Migrate Padloper to ProcessWire Commerce', __FILE__),
				'summary' => __('Module to help migrate Padloper to ProcessWire Commerce', __FILE__),
				'author' => 'Francis Otieno (Kongondo)',
				'version' => "001",
				'href' => 'http://kongondo.com',
				// non-supusers need this permission before ProcessWire will load this module
				'permission' => 'pwcommerce-migrate',
				'singular' => true,
				'requires' => [
					'PHP>=8.2.0',
					'ProcessWire>=3.0.200'
				],
				// Array of permissions that ProcessWire will install (and uninstall) automatically. Permissions should be in the format: array('permission-name' => 'Permission description').
				'permissions' => [
					'pwcommerce-migrate' => __('Permission to use Migrate Padloper to ProcessWire Commerce admin.', __FILE__),
				],

			];



		// ------
		return $moduleInfo;
	}

	public function __construct() {
		parent::__construct();
	}

	public function init() {
		parent::init();
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ EXECUTES  ~~~~~~~~~~~~~~~~~~

	public function execute() {

		$this->headline($this->_("Migrate Padloper to ProcessWire Commerce"));

		$out = "<h3>" .
			$this->_('Important Read')
			. "</h3>";
		$out .= "<p>" .

			$this->_("This tool will migrate your Padloper shop to ProcessWire Commerce shop. Please carefully read and action the following notes!") .

			"</p>";

		// $this->_debug();

		// -----
		// NOTES
		$out .= $this->renderNotes();

		// #########

		// VALIDATION
		$errors = $this->runChecks();
		if (!empty($errors)) {
			$out .= "<h3>" .
				$this->_('Error Encountered')
				. "</h3>";
			$out .= "Migration cannot work due to the following errors: {$errors}";
		} else {
			// GOOD TO GO
			// set session
			$this->setMigrationSession();
			// render get started button
			$out .= $this->renderStartMigration();
		}

		//--------------------
		return $out;
	}

	public function executeGetStarted() {
		// TODO DELETE NO LONGER IN USE
		$this->headline($this->_("Get Started"));
		// TODO CHECK IF MIGRATION SESSION IS ON!
		if (empty($this->isMigrationSessionValid())) {
			$error = $this->_('Invalid Migration Session');
			$this->error($error);
			$this->session->redirect($this->page->url);
		};
		// NOTE: notes SHOW WHAT'S TO BE DONE + WHAT REQUIRES MANUAL CHANGES, E.G. $padloper and hooks, i.e. PADLOPER::someMethod in ready.php becomes PwCommerce::someMethod. Note case!
		$out = "<p>GET STARTED!</p>";
		return $out;
	}

	public function executeMigrate() {
		$this->headline($this->_("Run Migration"));
		// TODO CHECK IF MIGRATION SESSION IS ON!
		if (empty($this->isMigrationSessionValid())) {
			$error = $this->_('Invalid Migration Session');
			$this->error($error);
			$this->session->redirect($this->page->url);
		};

		$input = $this->input;
		if ($input->post('migration_run')) {
			
			$this->handleMigrationRun();
		} elseif ($input->post('migration_cancel')) {
			
			$this->handleMigrationCancel();
		}

		$message = $this->_("Migration is ready to start. Please review and proceed when ready. If the information below does not look right please cancel. Make manual changes if necessary. If happy to proceed please click the run migration button. The migration process might take a while. Please be patient.");


		// show message
		$out = "<p>" .
			$message .

			"</p>" .
			// show migration changes: BEFORE VS AFTER
			$this->renderMigrationChanges() .
			// show RUN AND CANCEL BUTTONs
			$this->renderMigrationButtons();
		return $out;
	}

	public function executeFinishedMigration() {
		$this->headline($this->_("Migration Finished"));
		// TODO SHOW SUCCESS AND/OR ERRORS - SAVED TO CACHE. CACHE WILL SELF EXPIRE
		$cacheName = self::PWCOMMERCE_MIGRATION_NOTICES_CACHE_NAME;
		$migrationNotices = $this->getMigrateSavedCache($cacheName);
		

		if (empty($migrationNotices)) {
			$out = "<p>" .
				$this->_('Migration process is complete. For some reason we could not find notices about the migration. Please manually review that everything was properly migrated.') .
				"</p>";
		} else {
			$out = "<p>" .
				$this->_('Migration process is complete. Please review the following notices. Please check if you can manually resolve any errors. Please note there might be false positives.') .
				"</p>";

			// notices
			$out .= "<ul id='migrate_padloper_pwcommerce_notices'>";

			foreach ($migrationNotices as $migrationNoticeTopic => $notices) {
				$out .= "<li><span>" .
					// notice heading
					$this->getFormattedMigrationNotice($migrationNoticeTopic) .
					"</span>";
				// notices (nested)
				$out .= "<ol>";
				foreach ($notices as $noticeValues) {
					$class = $noticeValues['is_success'] ? "" : " class='migrate_padloper_pwcommerce_notice_error'";
					$out .= "<li><span{$class}>{$noticeValues['notice']}</span></li>";
				}
				// close nested list then outer list li
				$out .= "</ol></li>";
			}

			$out .= "</ul>";
		}



		// --------
		return $out;
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ VALIDATORS  ~~~~~~~~~~~~~~~~~~

	private function isInstalledModule($class) {
		return $this->wire('modules')->isInstalled($class);
	}

	private function isMigrationSessionValid() {
		$isValidMigrationSession = true;
		// check if session is set
		// check if session set is longer than 1 hour 
		// TODO  time ok?
		$migrationSession = $this->getMigrationSession();
		


		if (empty($migrationSession)) {
			$isValidMigrationSession = false;
		} elseif (!empty($this->isStaleMigrationSession())) {
			$isValidMigrationSession = false;
		}

		return $isValidMigrationSession;
	}

	private function isStaleMigrationSession() {
		// NOTE: TIMESTAMP
		$migrationSession = (int) $this->getMigrationSession();
		$currentTime = time();
		// stale session is one that is more than 1 hour old
		$isStaleSession = $currentTime - $migrationSession > 3600;
		
		
		
		return $isStaleSession;
	}

	private function runChecks() {
		$errorsArray = $this->getErrors();
		$errorsString = "";
		if (!empty($errorsArray)) {
			$errorsString = implode(", ", $errorsArray);
		}
		return $errorsString;
	}

	private function getErrors() {

		$errors = [];

		$padloperClass = 'Padloper';
		$pwCommerceClass = 'PwCommerce';


		// is padloper installed
		if (empty($this->isInstalledModule($padloperClass))) {
			$errors[] = $this->_('Padloper install not found!');
		}
		// is pwcommerce installed
		// IT SHOULDN'T!
		if (!empty($this->isInstalledModule($pwCommerceClass))) {
			$errors[] = $this->_('ProcessWire Commerce install found! Migration not possible!');
		}


		
		return $errors;
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ SESSION  ~~~~~~~~~~~~~~~~~~

	private function setMigrationSession() {
		// IF WE ALREADY HAVE A SESSION AND IT IS NOT MORE THAN 1 HOUR LONG > WE REUSE IT
		if (!empty($this->isStaleMigrationSession())) {
			$this->session->set(self::MIGRATION_SESSION_NAME, time());
		}
	}

	private function getMigrationSession() {
		$migrationSession = $this->session->get(self::MIGRATION_SESSION_NAME);
		return $migrationSession;
	}

	private function removeMigrationSession() {
		$this->session->remove(self::MIGRATION_SESSION_NAME);
	}



	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GETTERS  ~~~~~~~~~~~~~~~~~~

	private function getPadloperPages() {
		// TODO probably not needed! we only need the shop root page then get its children
		// for children in main tree, no need to bother them
	}
	private function getPadloperTemplates(): TemplatesArray {
		// $padloperTemplates = $this->wire('templates')->find("name%=padloper");

		/** @var Templates $templates */
		$templates = $this->wire('templates');

		/** @var TemplatesArray $padloperTemplates */
		$padloperTemplates = $templates->find("name^=padloper");
		return $padloperTemplates;
	}

	private function getPadloperTemplateFiles() {
		// TODO NOT IN USE?
	}

	private function getPadloperBackendTemplatePartials() {
		// NOTE ONLY NEEDED FOR 'backend'
		// NOTE - AT THIS POINT, /site/templates/padloper/ has already been renamed to /site/templates/pwcommmerce/ !!!
		// NOTE - what we want is to rename the files inside /site/templates/pwcommerce/backend/
		$backendTemplatePartialsPath = $this->config->paths->templates . self::PADLOPER_BACKEND_TEMPLATES_PATH;

		/** @var WireFileTools $files */
		$files = $this->wire('files');
		$backendTemplatePartialsFiles = $files->find($backendTemplatePartialsPath);
		return $backendTemplatePartialsFiles;
	}

	private function getPWCommerceBackendTemplatePartials() {
		// NOTE ONLY NEEDED FOR 'backend'
		// NOTE - AT THIS POINT, /site/templates/padloper/ has already been renamed to /site/templates/pwcommmerce/ !!!
		// NOTE - what we want is to rename the files inside /site/templates/pwcommerce/backend/
		$backendTemplatePartialsPath = $this->config->paths->templates . self::PWCOMMERCE_BACKEND_TEMPLATES_PATH;

		/** @var WireFileTools $files */
		$files = $this->wire('files');
		$backendTemplatePartialsFiles = $files->find($backendTemplatePartialsPath);
		return $backendTemplatePartialsFiles;
	}

	private function getPadloperFields() {
		// $padloperFields = $this->wire('fields')->find("name%=padloper");

		/** @var Fields $fields */
		$fields = $this->wire('fields');

		/** @var FieldsArray $padloperFields */
		$padloperFields = $fields->find("name^=padloper");
		return $padloperFields;
	}

	private function getPadloperCustomFields($isPostRename = false): WireArray {
		// NOTE: by this point, 'field->name^=padloper' could be 'field->name^=pwcommerce'
		$fieldName = $isPostRename ? 'pwcommerce' : 'padloper';

		/** @var Fields $fields */
		$fields = $this->wire('fields');
		$padloperCustomFields = $fields->find("name^=$fieldName, type%=padloper");
		
		return $padloperCustomFields;
	}

	private function getPWCommerceCustomFields(): WireArray {
		/** @var Fields $fields */
		$fields = $this->wire('fields');
		$pwcommerceCustomFields = $fields->find("name^=pwcommerce, type%=pwcommerce");
		
		return $pwcommerceCustomFields;
	}

	private function getPWCommerceCustomFieldsNames() {
		$padloperCustomFieldsNames = [
			'pwcommerce_customer',
			'pwcommerce_customer_addresses',
			'pwcommerce_discount',
			'pwcommerce_discounts_apply_to',
			'pwcommerce_discounts_eligibility',
			'pwcommerce_download_settings',
			'pwcommerce_notes',
			'pwcommerce_order',
			'pwcommerce_order_customer',
			'pwcommerce_order_discounts',
			'pwcommerce_order_line_item',
			'pwcommerce_product_properties',
			'pwcommerce_product_settings',
			'pwcommerce_product_stock',
			'pwcommerce_runtime_markup',
			'pwcommerce_shipping_fee_settings',
			'pwcommerce_shipping_rate',
			'pwcommerce_tax_overrides',
			'pwcommerce_tax_rates',
		];
		return $padloperCustomFieldsNames;
	}


	private function getPadloperAssetsFolder(): string {
		$padloperAssetsFolderPath = $this->config->paths->templates . self::PADLOPER_PARTIAL_TEMPLATES_PATH;
		
		return $padloperAssetsFolderPath;
	}

	private function getPadloperInstallSettings() {
		/** @var Modules $modules */
		$modules = $this->wire('modules');
		$configs = $modules->getConfig(self::PADLOPER_PROCESS_MODULE);
		return $configs;
	}

	private function getProcessPadloperShopPage() {
		// ProcessPadloper page
		// i.e. /admin/shop/
		$parent = $this->wire('pages')->get($this->wire('config')->adminRootPageID);
		$shopPage = $this->wire('pages')->get("parent=$parent, template=admin, include=all, name=" . self::PADLOPER_SHOP_NAME);
		return $shopPage;
	}

	private function getPadloperRootPage($isPostRename = false) {
		// root page of all padloper pages
		// child of the ProcessPadloper page
		// i.e. /admin/shop/padloper/
		// NOTE: by this point, 'template=padloper' could be 'template=pwcommerce'
		$templateName = $isPostRename ? 'pwcommerce' : 'padloper';
		$parent = $this->getProcessPadloperShopPage();
		$rootPage = $this->wire('pages')->get("parent=$parent, template=$templateName, include=all, name=" . self::PADLOPER_ROOT_PAGE_NAME);

		
		
		return $rootPage;
	}

	private function getPadloperTemporaryRootParent() {
		// TEMPORARY root page of all padloper pages
		// child of /admin/temporary-shop/
		$parent = $this->wire('pages')->get($this->wire('config')->adminRootPageID);
		$temporaryRootParent = $this->wire('pages')->get("parent=$parent, template=admin, include=all, name=" . self::PWCOMMERCE_TEMPORARY_ROOT_PARENT_NAME);
		return $temporaryRootParent;
	}

	private function getPWCommerceRootPageFromTemporaryRootParent() {
		// root page of all padloper pages
		// TEMPORARY child of the /admin/shop/temporary-shop/ page
		$parent = $this->getPadloperTemporaryRootParent();
		// note: at this stage template has been renamed but not the page name or title!
		// @see: $this->actionMigrateRootPage()
		$rootPage = $this->wire('pages')->get("parent=$parent, template=pwcommerce, include=all, name=" . self::PADLOPER_ROOT_PAGE_NAME);
		return $rootPage;
	}

	private function getPWCommerceProcessPage() {
		/** @var Modules $modules */
		$modules = $this->wire('modules');
		/** @var Process $process */
		$process = $modules->get(self::PWCOMMERCE_PROCESS_MODULE);
		$processPage = $process->getProcessPage();
		return $processPage;
	}

	private function getPadloperCustomerRole() {
		/** @var Roles $roles */
		$roles = $this->wire('roles');
		$customerRole = $roles->get(self::PADLOPER_CUSTOMER_ROLE_NAME);
		return $customerRole;
	}

	private function getUninstallPadloperModulesNames() {
		// NOTE: in order of uninstall
		$padloperModules = [
			'PadloperHooks',
			// NOTE - table not found issues
			'Padloper',
			'ProcessPadloper',
		];
		return $padloperModules;
	}

	private function getInstallPWCommerceModulesNames() {
		// NOTE: in order of install
		$pwcommerceModules = [
			'ProcessPWCommerce',
			'PwCommerce',
			'PwCommerceHooks',
		];
		return $pwcommerceModules;
	}

	private function getClassShortName($object) {
		$shortName = (new \ReflectionClass($object))->getShortName();
		return $shortName;
	}

	private function getCachedExportedPadloperInstallSettings() {
		$cacheName = self::PWCOMMERCE_IMPORTED_INSTALL_SETTINGS_CACHE_NAME;
		$importedInstallSettings = $this->getMigrateSavedCache($cacheName);
		return $importedInstallSettings;
	}


	private function getMigrateSavedCache($cacheName) {
		/** @var WireCache $cache */
		$cache = $this->wire('cache');
		$cachedValue = $cache->get($cacheName);
		return $cachedValue;
	}



	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ NOTES  ~~~~~~~~~~~~~~~~~~

	private function renderNotes() {
		$out = "<ol>";
		foreach ($this->getNotes() as $note) {
			$out .= "<li>{$note}</li>";
		}
		$out .= "</ol>";
		return $out;
	}

	private function getNotes() {
		$notes = [
			$this->_('Usage of this tool is at your own risk.'),
			$this->_('Create a whole backup of your site before getting started.'),
			$this->_('DO NOT MANUALLY UNINSTALL Padloper! This tool will do that for you. It will also uninstall all related Modules and Fields and preserve existing fields data. Otherwise, you risk losing all your data (pages deleted).'),
			$this->_('DO NOT MANUALLY INSTALL ProcessWire Commerce! This tool will do that for you. It will also install related Modules and Fields and import existing fields data.'),
			$this->_("Download and unzip ProcessWire Commerce to '/site/modules/'."),
			$this->_("Do a Modules Refresh so that ProcessWire will see ProcessWire Commerce modules. Make sure you see notices about 'found new module...'"),
			$this->_('Preferably, test a migration on a test server first.'),
			$this->_('If the tests pass, it is still advisable to create a duplicate of your production site, run the migration there, create a database dump of the migrated site and use that to update your real production site.'),
			$this->_('You might have to manually uninstall/install some Padloper/ProcessWire Commerce modules.'),
		];
		return $notes;
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MISC  ~~~~~~~~~~~~~~~~~~

	private function renderStartMigration() {

		$out = "<h3>" .
			$this->_('Get Started')
			. "</h3>";

		$out .= "<p>" .

			$this->_("Click the button to get started with the migration.") .
			"</p>";


		$href = $this->page->url . "migrate/";
		$options = [
			'name' => 'pwmigrate_get_started',
			'label' => $this->_('Get Started'),
			'type' => 'button',
			'href' => $href,
		];
		$field = $this->getButton($options);

		$out .= $field->render();
		return $out;
	}

	private function renderMigrationChanges() {

		// automated changes
		$out = "<h3>" .
			$this->_('Automated Changes')
			. "</h3>";
		$out .= '<p>' .

			$this->_('Please note that Templates, Fields, Roles, and Assets will be RENAMED, Fieldtypes will be REASSIGNED, Pages will be REPARENTED and settings will be imported and REAPPLIED.') .

			'</p>';

		$out .= $this->renderMigrationAutomatedChangesList();

		// other automated changes

		$out .= "<h3>" .
			$this->_('Other Automated Changes')
			. "</h3>";
		$out .= '<p>' .

			$this->_("During the install, the migration tool will uninstall 'Padloper' and related modules without loss of data. It will subsequently install 'ProcessWire Commerce'.") .

			'</p>';


		// manual changes
		$out .= "<h3>" .
			$this->_('Required Manual Changes')
			. "</h3>";

		$out .= $this->renderMigrationRequiredManualChanges();
		return $out;
	}

	private function renderMigrationAutomatedChangesList() {

		$items = [
			'before',
			'after',
			// not in use for now!
			// 'notes',
		];

		$colspan = count($items);


		$allTasksItems = $this->getMigrationChangesTasksItems();
		

		$out =
			"<table id='migrate_padloper_pwcommerce'>" .

			"<thead>" .
			"<tr>" .
			"<th>" . $this->_('Before') . "</th>" .
			"<th>" . $this->_('After') . "</th>" .
			// "<th>" . $this->_('Notes') . "</th>" .
			"</tr>" .
			"</thead>" .
			"<tbody>";

		foreach ($this->getMigrationChangesTasksList() as $task => $taskHeading) {


			$taskItems = $allTasksItems[$task];

			// task heading
			$out .=
				"<tr>
				<th colspan='{$colspan}'>{$taskHeading}</th>			
				</tr>";
			// task items
			$out .= "<tr>";
			foreach ($items as $item) {
				if ($item === 'before') {
					// BEFORE
					$taskItemsList = $this->renderSingleTaskItems($task, $taskItems);
				} else {
					// AFTER
					$taskItemsList = $this->renderSingleTaskItems($task, $taskItems, false);
				}
				// populate the TD
				$out .= "<td>{$taskItemsList}</td>";
			}
			$out .= "</tr>";
		}

		$out .=
			"<tbody>" .
			"</table>";

		return $out;
	}

	private function renderMigrationRequiredManualChanges() {

		$changesNotice = $this->_('Please note that you will need to make some changes to your template files. These are outlined below.');

		$changesTemplateFiles = $this->_("Template Files: All instances of '\$padloper' should be replaced by '\$pwcommerce'. For instance '\$padloper->getCart()' should become '\$pwcommerce->getCart()'.");

		$changesHooks = $this->_("Hooks: Your hooks, e.g. in ready.php should be renamed as follows: All instances of 'Padloper::someHookedMethod' should become 'PwCommerce::someHookedMethod'. Please note the spelling is case-sensitive.");
		$out =

			"<p>" .

			$changesNotice .
			"</p>" .

			"<ol>" .
			"<li>" . $changesTemplateFiles . "</li>" .
			"<li>" . $changesHooks . "</li>" .

			"</ol>";

		return $out;
	}

	private function renderSingleTaskItems($task, $taskItems, $isBefore = true) {
		$out = "<ol>";

		foreach ($taskItems as $taskItem) {

			if ($task === 'fieldtypes') {
				// if fieldtypes, we get the 'type'
				$itemStr = $this->getClassShortName($taskItem->type);
			} elseif ($task === 'pages') {
				// path if pages
				$itemStr = $taskItem->path;
			} elseif ($task === 'assets') {
				$itemStr = $taskItem;
			} elseif ($task === 'install_settings') {
				// json if configs
				$itemStr = json_encode($taskItem, JSON_PRETTY_PRINT);
			} else {
				// use name for templates, fields and roles
				$itemStr = $taskItem->name;
				if (empty($itemStr)) {
					
					$itemStr = $this->_('None found');
				}
			}

			// Padloper vs PWCommerce
			$itemStr = $isBefore ? $itemStr : $this->getMigrationChangeRename($itemStr);
			$out .= "<li>{$itemStr}</li>";
		}
		$out .= "</ol>";
		return $out;
	}

	private function renderMigrationButtons() {

		/** @var Modules $modules */
		$modules = $this->wire('modules');

		// migration form
		/** @var InputfieldForm $form */
		$form = $modules->get('InputfieldForm');

		// run migration button
		$options = [
			'type' => 'submit',
			'label' => 'Run Migration',
			'name' => 'migration_run',
		];

		$field = $this->getButton($options);
		$form->add($field);

		// cancel button
		$options = [
			'is_secondary' => true,
			'type' => 'submit',
			'label' => 'Cancel Migration',
			'name' => 'migration_cancel',
		];

		$field = $this->getButton($options);
		$form->add($field);

		$out = $form->render();

		return $out;
	}

	private function getButton($options) {

		/** @var InputfieldButton $field */
		$field = $this->wire('modules')->get('InputfieldButton');
		$type = !empty($options['type']) ? $options['type'] : 'button';

		$field->attr([
			'name' => $options['name'],
			'value' => $options['label'],
			'type' => $type,

		]);

		if (!empty($options['href'])) {
			$field->attr('href', $options['href']);
		}

		if (!empty($options['is_secondary'])) {
			$field->setSecondary();
		}

		return $field;
	}

	private function getMigrationChangesTasksList() {
		$tasksList = [
			'templates' => $this->_('Templates'),
			'fields' => $this->_('Fields'),
			'fieldtypes' => $this->_('Fieldtypes'),
			'pages' => $this->_('Pages'),
			'roles' => $this->_('Roles'),
			'assets' => $this->_('Assets'),
			'install_settings' => $this->_('Install Settings'),
		];

		return $tasksList;
	}

	private function getMigrationChangesTasksItems() {
		// assets folder
		$assets = [
			$this->getPadloperAssetsFolder()
		];
		// /site/templates/padloper/backend/*.* partials
		$assets = array_merge($assets,  $this->getPadloperBackendTemplatePartials());

		$subTasksList = [
			'templates' => $this->getPadloperTemplates(),
			'fields' => $this->getPadloperFields(),
			'fieldtypes' => $this->getPadloperCustomFields(),
			'pages' => [$this->getPadloperRootPage()],
			'roles' => [$this->getPadloperCustomerRole()],
			'assets' => $assets,
			'install_settings' => $this->getPadloperInstallSettings(),
		];

		return $subTasksList;
	}

	private function getMigrationChangesBeforeItems($task) {
		// TODO DELETE IF NOT IN USE
		$allTasksItems = $this->getMigrationChangesTasksItems();
		$taskItems = $allTasksItems[$task];
		return $taskItems;
	}

	private function getMigrationChangeRename($item) {
		$search = ['Padloper', 'padloper', 'PADLOPER'];
		$replace = ['PWCommerce', 'pwcommerce', 'PWCOMMERCE'];
		$renamedItem = str_replace($search, $replace, $item);
		return $renamedItem;
	}

	private function setFormattedMigrationNotice($task, $isSuccess, $extra = "") {
		$notice = $this->getMigrationNotice($task, $isSuccess);
		if (!empty($extra)) {
			$notice .= ": {$extra}";
		}
		// set migration notice
		// NOTE: nested array
		// $this->migrationNotices[$task][] = $notice;
		$this->migrationNotices[$task][] = [
			'notice' => $notice,
			'is_success' => $isSuccess
		];
	}

	private function getFormattedMigrationNotice($rawNotice) {
		$formattedNotice = ucwords(str_replace("_", " ", $rawNotice));
		return $formattedNotice;
	}

	private function getMigrationNotices() {

		$notices = [

			'templates' => [
				'error' => $this->_('Error: Template not renamed'),
				'success' => $this->_('Success: Template renamed'),
			],
			'fields' => [
				'error' => $this->_('Error: Field not renamed'),
				'success' => $this->_('Success: Field renamed'),
			],
			'fieldtypes' => [
				'error' => $this->_('Error: Fieldtype not reassigned'),
				'success' => $this->_('Success: Fieldtype reassigned'),
			],
			'pages' => [
				'error' => $this->_('Error: Pages not reparented'),
				'success' => $this->_('Success: Pages reparented'),
			],
			'pages_temporary_reparent' => [
				'error' => $this->_('Error: Pages not temporarily reparented'),
				'success' => $this->_('Success: Pages temporarily reparented'),
			],
			'pages_create' => [
				'error' => $this->_('Error: Pages not created'),
				'success' => $this->_('Success: Pages created'),
			],
			'pages_delete' => [
				'error' => $this->_('Error: Pages not deleted'),
				'success' => $this->_('Success: Pages deleted'),
			],
			'roles' => [
				'error' => $this->_('Error: Role not renamed'),
				'success' => $this->_('Success: Role renamed'),
			],
			'assets' => [
				'error' => $this->_('Error: Asset not renamed'),
				'success' => $this->_('Success: Asset renamed'),
			],
			'install_settings_cache' => [
				'error' => $this->_('Error: Install Settings not temporarily cached'),
				'success' => $this->_('Success: Install Settings temporarily cached'),
			],
			'install_settings' => [
				'error' => $this->_('Error: Install Settings not reapplied'),
				'success' => $this->_('Success: Install Settings reapplied'),
			],
			'install_settings_delete_cache' => [
				'error' => $this->_('Error: Install Settings cache not deleted'),
				'success' => $this->_('Success: Install Settings cache deleted'),
			],
			// OTHER
			'install_module' => [
				'error' => $this->_('Error: Module not installed'),
				'success' => $this->_('Success: Module installed'),
			],
			'uninstall_module' => [
				'error' => $this->_('Error: Module not uninstalled'),
				'success' => $this->_('Success: Module uninstalled'),
			],
			'session' => [
				'error' => $this->_('Error: Migration session not removed'),
				'success' => $this->_('Success: Migration session removed'),
			],
			'migration_notices_cache' => [
				'error' => $this->_('Error: Migration Notices not cached'),
				'success' => $this->_('Success: Migration Notices cached'),
			],
		];

		
		return $notices;
	}

	private function getMigrationNotice($task, $isSuccess) {
		$type = $isSuccess ? 'success' : 'error';
		$notices = $this->getMigrationNotices();
		$notice = $notices[$task][$type];
		return $notice;
	}



	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MIGRATORS  ~~~~~~~~~~~~~~~~~~

	private function actionRunMigration() {
		// NOTE: THIS WILL RUN THE MIGRATION TOOLS BELOW, IN A PARTICULAR ORDER
		// NOTE: EACH ACTION WILL 'RECORD' SUCCESS OR ERROR
		// IN PENULTIMATE METHOD, WE SAVE THOSE TO CACHE
		/*
		STEPS + METHODS
		------------------

		A. PREPARATION
		1. Install ProcessMigratePadloper module
		2. Read the instructions

		B. PRE-VALIDATION
		1. IS PADLOPER INSTALLED
		@method: $this->runChecks()

		2. IS PROCESSWIRE COMMERCE NOT INSTALLED
		@method: $this->runChecks()

		@note: STEPS A & B just for info
		@see: $this->execute()

		++++++++++++++++++++++++++++++

		C. RUN MIGRATION

		1. Migrate Templates
		- i.e. rename 'padloper-xxx' to 'pwcommerce-xxx'
		- e.g. 'padloper-product' becomes 'pwcommerce-product'

		@method: $this->actionMigrateTemplates()

		2. Migrate Fields
		- i.e. rename 'padloper_xxx' to 'pwcommerce_xxx'
		-  e.g. 'padloper_images' -> 'pwcommerce_images'
		@note: these are all fields used by Padloper; not just custom ones mentioned below.

		@method: $this->actionMigrateFields()

		3. Migrate Field Types
		a. Install PWCommerce Custom FieldTypes and InputfieldTypes
		- there's 19 of them including 'FieldtypePWCommerceRuntimeMarkup'
		@note: it is OK to install them here since they don't require ProcessPWCommerce (which will be installed at a later stage).
		- NOTE:  will be 19 if all optional features are installed!

		b. Change pwcommerce_fields TYPES for these custom fields
		- note: these and other non-custom fields (e.g. padloper_settings) were renamed in #2
		- e.g. 'pwcommerce_notes'  ('padloper_notes') changes type FROM 'FieldtypePadloperNotes' to 'FieldtypePWCommerceNotes'
			
		@method: $this->actionMigrateCustomFieldsTypes()

		4. Migrate Pages: Stage 1
		a. Create Temporary Shop Root Page, i.e. /admin/temporary-shop/
		b. Move /admin/shop/padloper/ to /admin/temporary-shop/padloper/

		@method: $this->actionMigrateCreateTemporaryRootParent()
		@method: $this->actionMigrateTemporaryRootPage()

		5. Cache Padloper Settings
		a. Save the settings/configs from ProcessPadloper
		- for reuse when we install PWCommerce
		- i.e., 'export' them

		@method: $this->actionMigrateExportPadloperInstallSettings()

		6. Uninstall Padloper
		a. Uninstall PadloperHooks
		b. Uninstall Padloper
		c. Uninstall ProcessPadloper

		@method: $this->actionMigrateUninstallPadloperModules()

		7. Install ProcessWire Commerce
		a. Install ProcessPWCommerce
		b. Install PwCommerce (i.e. $pwcommerce)
		c. Install PwCommerceHooks

		@method: $this->actionMigrateInstallPWCommerceModules()

		8. Import Cached Padloper Settings
		a. Save the settings/configs from ProcessPadloper to ProcessPWCommerce
		- this ensures Padloper installed features remain the same after migration
		- no need to reinstall!

		@method: $this->actionMigrateImportInstallSettings()

		9. Migrate Pages: Stage 2
		a. rename /admin/temporary-shop/padloper/ to /admin/temporary-shop/pwcommerce/
		b. change its title from 'Padloper' to 'PWCommerce'

		c. Move /admin/temporary-shop/pwcommerce/ to /admin/shop/pwcommerce/
		- i.e., a child of  'Shop' which is now the Process Page of the module ProcessPWCommerce.module

		d. Delete /admin/temporary-shop/ PAGE

		@method: $this->actionMigrateRootPage()
		@method: $this->actionMigrateDeleteTemporaryRootParent()

		10. Uninstall Custom Padloper FieldTypes and InputfieldTypes
		- e.g. 'FieldtypePadloperNotes'
		- There's 19 of them including 'FieldtypePadloperCustomer'
		- They can be uninstalled because no longer in use having changed 'type'  in a step above
		- NOTE:  will be 19 if all optional features are installed!

		@method: $this->actionMigrateUninstallPadloperCustomFields()

		11. Migrate Role
		a. Rename 'padloper-customer' role to 'pwcommerce-customer'
		@note this means we don't have to reassign the role to existing customers; the role ID would stay the same.

		@method: $this->actionMigrateCustomerRole()

		12. Migrate Assets
		a. Rename the folder /site/templates/padloper to /site/templates/pwcommerce
		b. Rename the files in /site/templates/pwcommerce/backend/*.*
		- e.g. 'padloper-process-render-orders.php' to 'pwcommerce-process-render-orders.php'

		@method: $this->actionMigratePadloperAssetsFolder()
		@method: $this->actionMigrateBackendTemplatePartials()

		13. Cache Notices
		a. We will use the cache after cleanup redirects to /finished-migration/

		@method: $this->actionCacheMigrationNotices()

		14. Cleanup
		a. clear saved cache with Padloper Install Configs/Settings.
		b. remove migration session.
		c. redirect to finished page and show notices

		@method: $this->actionMigrateCleanup()
		
		*/

		/** @var Modules $modules */
		$modules = $this->wire('modules');
		$modules->refresh();


		############# RUN MIGRATION! #################
		// 1. Migrate Templates - @method: $this->actionMigrateTemplates()
		$this->actionMigrateTemplates();
		// -------------
		// 2. Migrate Fields - @method: $this->actionMigrateFields()
		$this->actionMigrateFields();
		// -------------
		// 3. Migrate Field Types - @method: $this->actionMigrateCustomFieldsTypes()
		$this->actionMigrateCustomFieldsTypes();
		// -------------
		// 4. Migrate Pages: Stage 1 - @method: $this->actionMigrateCreateTemporaryRootParent(), $this->actionMigrateTemporaryRootPage()
		$this->actionMigrateCreateTemporaryRootParent();
		$this->actionMigrateTemporaryRootPage();
		// -------------
		// 5. Cache Padloper Settings - @method: $this->actionMigrateExportPadloperInstallSettings()
		$this->actionMigrateExportPadloperInstallSettings();
		// -------------
		// 6. Uninstall Padloper - @method: $this->actionMigrateUninstallPadloperModules()
		$this->actionMigrateUninstallPadloperModules();
		// -------------
		// 7. Install PWCommerce - @method: $this->actionMigrateInstallPWCommerceModules()
		$this->actionMigrateInstallPWCommerceModules();
		// -------------
		// 8. Import Cached Padloper Settings - @method: $this->actionMigrateImportInstallSettings()
		$this->actionMigrateImportInstallSettings();
		// -------------
		// 9. Migrate Pages: Stage 2 - @method: $this->actionMigrateRootPage(), $this->actionMigrateDeleteTemporaryRootParent()
		$this->actionMigrateRootPage();
		$this->actionMigrateDeleteTemporaryRootParent();
		// -------------
		// 10. Uninstall Custom Padloper FieldTypes and InputfieldTypes - @method: $this->actionMigrateUninstallPadloperCustomFields()
		$this->actionMigrateUninstallPadloperCustomFields();
		// -------------
		// 11. Migrate Role - @method: $this->actionMigrateCustomerRole()
		$this->actionMigrateCustomerRole();
		// -------------
		// 12. Migrate Assets - @method: $this->actionMigratePadloperAssetsFolder(), $this->actionMigrateBackendTemplatePartials()
		$this->actionMigratePadloperAssetsFolder();
		$this->actionMigrateBackendTemplatePartials();
		// -------------
		// 13. Cache Notices - @method: $this->actionCacheMigrationNotices()
		$this->actionCacheMigrationNotices();
		// -------------
		// 14. Cleanup - @method: $this->actionMigrateCleanup()
		$this->actionMigrateCleanup();
		// -------------
	}

	private function actionMigratePages() {
		// TODO DELETE IF NOT IN USE
	}


	private function actionMigrateTemplates() {
		// TODO ALSO NEED TO RENAME LABELS!
		$padloperTemplates = $this->getPadloperTemplates();
		
		if (!empty($padloperTemplates->count())) {
			/** @var Template $template */
			foreach ($padloperTemplates as $template) {
				
				$name = str_replace("padloper", "pwcommerce", $template->name);
				$label = str_replace("Padloper", "PWCommerce", $template->label);

				$description = null;

				if (!empty($template->description)) {
					$description = str_replace("padloper", "pwcommerce", $template->description);
				}

				
				
				
				$this->wire('templates')->rename($template, $name);
				$template->label = $label;
				if (!empty($description)) {
					$template->description = $description;
				}
				$bool = $this->wire('templates')->save($template);
				// set notice for each template name
				$this->setFormattedMigrationNotice('templates', $bool, $name);
			}
		}
	}

	private function actionMigrateTemplateFiles() {
		// TODO not needed?
	}

	private function actionMigrateBackendTemplatePartials() {
		// NOTE - AT THIS POINT, /site/templates/padloper/ has already been renamed to /site/templates/pwcommmerce/ !!!
		// NOTE - what we want is to rename the files inside /site/templates/pwcommerce/backend/
		$backendTemplatePartialsFiles = $this->getPWCommerceBackendTemplatePartials();
		
		/** @var WireFileTools $files */
		$files = $this->wire('files');
		if (!empty($backendTemplatePartialsFiles)) {
			// TODO RENAME THEM
			foreach ($backendTemplatePartialsFiles as $oldName) {
				$newName = str_replace("padloper", "pwcommerce", $oldName);
				// TODO CATCH ERRORS?
				$bool = $files->rename($oldName,  $newName);
				
				
				
				// set notice for each template partial name
				$this->setFormattedMigrationNotice('assets', $bool, $newName);
			}
		}
	}

	private function actionMigrateFields() {
		$padloperFields = $this->getPadloperFields();
		
		if (!empty($padloperFields->count())) {
			/** @var Field $field */
			foreach ($padloperFields as $field) {
				$name = str_replace("padloper", "pwcommerce", $field->name);
				$label = str_replace("Padloper", "PWCommerce", $field->label);

				$description = null;

				if (!empty($field->description)) {
					$description = str_replace("padloper", "pwcommerce", $field->description);
				}

				
				
				
				
				$field->name = $name;
				$field->label = $label;
				if (!empty($description)) {
					$field->description = $description;
				}
				$bool = $this->wire('fields')->save($field);
				// set notice for each field name
				$this->setFormattedMigrationNotice('fields', $bool, $name);
			}
		}
	}

	private function actionMigrateCustomFieldsTypes() {

		// the padlpoper custom fields (e.g. 'padloper_customer') whose TYPES need changing to PWCommerce ones
		// NOTE: by this point, 'field->name^=padloper' IS 'field->name^=pwcommerce'
		// NOTE - we want to retain the fields (db records) themselves
		$padloperCustomFields = $this->getPadloperCustomFields(true);
		// the PW commerce whose objects we will use to change the types of field above
		// we use $field->name to match them
		// $pwcommerceCustomFields = $this->getPWCommerceCustomFields();


		
		



		// NOTE: WE INSTALL THE CUSTOM FIELDS ON THE FLY IN THE LOOP!
		// E.G. IF INSTALL HAS padloper_notes, we install pwcommerce_notes

		if (!empty($padloperCustomFields->count())) {
			/** @var Field $padloperCustomField */
			foreach ($padloperCustomFields as $padloperCustomField) {
				// GET THE SHORTNAME OF THE CLASS OF THE CURRENT FIELDTYPE
				// e.g. 'FieldtypePadloperNotes'
				$padloperCustomFieldTypeClass = $this->getClassShortName($padloperCustomField->type);


				// e.g. becomes 'FieldtypePWCommerceNotes'
				$pwcommerceCustomFieldTypeClass = str_replace("Padloper", "PWCommerce", $padloperCustomFieldTypeClass);
				
				
				

				$bool = false;
				try {
					// INSTALL MODULE
					// INSTALL THE PWCOMMERCE FIELD
					// TODO CONFIRM IT INSTALLS INPUTFIELD ALSO
					// $bool = true;
					$module = $this->actionMigrateInstallModule($pwcommerceCustomFieldTypeClass);
					$bool = !empty($module);
					// set notice for each custom field name installed
					$this->setFormattedMigrationNotice('install_module', $bool, $pwcommerceCustomFieldTypeClass);
					
					
				} catch (\Throwable $th) {
					//throw $th;
					$message = $th->getMessage();
					$message .= " ($pwcommerceCustomFieldTypeClass)";
					$this->setFormattedMigrationNotice('install_module', $bool, $message);
					
				}

				if (empty($module)) {
					// TODO ERROR CATCH?? exception will be thrown?
				} else {



					try {
						// SET/CHANGE FIELDTYPE
						$field = $padloperCustomField->setFieldtype($pwcommerceCustomFieldTypeClass);
						$bool = $this->wire('fields')->save($field);
						// type	string, Fieldtype Type should be either a Fieldtype object or the string name of a Fieldtype object.
						// $field->type
						// CHECK IF FIELDTYPE WAS SET
						$newFieldTypeClass = $this->getClassShortName($field->type);
						$bool = $newFieldTypeClass === $pwcommerceCustomFieldTypeClass;
						// set notice for each custom field type reassigned
						$this->setFormattedMigrationNotice('fieldtypes', $bool, $pwcommerceCustomFieldTypeClass);
						
						
						
						// ++++++++++++++
						// track custom fieldtype names for uninstall later
						$this->installedPadloperCustomerFieldsNames[] = $padloperCustomFieldTypeClass;
					} catch (\Throwable $th) {
						//throw $th;
						$bool = false;
						$message = $th->getMessage();
						$message .= " ($pwcommerceCustomFieldTypeClass)";
						$this->setFormattedMigrationNotice('fieldtypes', $bool, $message);
						
					}

					#############
					// NOTE: UNINSTALL PADLOPER CUSTOM FIELDTYPE will happen later
				}
			}
		}
	}

	private function actionMigratePadloperAssetsFolder() {
		$padloperAssetsFolder = $this->getPadloperAssetsFolder();
		$newName = str_replace("padloper", "pwcommerce", $padloperAssetsFolder);
		/** @var WireFileTools $files */
		$files = $this->wire('files');


		$isExistAssetsFolder = $files->exists($padloperAssetsFolder);
		$bool = false;

		if (!empty($isExistAssetsFolder)) {
			// TODO CATCH ERRORS?
			$bool = $files->rename($padloperAssetsFolder,  $newName);
			
			
		}

		// set notice for assets folder renamed
		$this->setFormattedMigrationNotice('assets', $bool, $newName);


		
		
	}

	private function actionMigrateCreateTemporaryRootParent() {
		// TEMPORARY ROOT PARENT to hold the children of PADLOPER /admin/shop/, i.e. the Padloper Process Page
		// this is so that we can uninstall ProcessPadloper without deleting shop pages!
		$page = new Page();
		$page->template = 'admin';
		$page->parent = $this->wire('pages')->get($this->wire('config')->adminRootPageID);
		$page->title = 'Temporary Shop';
		$page->name = self::PWCOMMERCE_TEMPORARY_ROOT_PARENT_NAME;
		$bool = $page->save();
		// set notice for temporary root parent page created
		$this->setFormattedMigrationNotice('pages_create', $bool, $page->path);
	}

	private function actionMigrateDeleteTemporaryRootParent() {
		$temporaryRootParent = $this->getPadloperTemporaryRootParent();
		$bool = $temporaryRootParent->delete();
		// set notice for temporary root parent page deleted
		$this->setFormattedMigrationNotice('pages_delete', $bool, $temporaryRootParent->path);
	}

	private function actionMigrateTemporaryRootPage() {
		// NOTE: by this point, the template 'padloper' has been renamed to 'pwcommerce'
		$rootPage = $this->getPadloperRootPage(true);
		$temporaryRootParent = $this->getPadloperTemporaryRootParent();
		
		
		// NOTE run after ProcessWire Commerce has been installed in order to get its Process Page!
		// NOTE at this point, these has been moved to a temporary parent
		// in order to circumvent the 'shop' name issue, i.e. needed by both Padloper and PW Commerce
		$rootPage->of(false);
		// reparent it temporarily
		$rootPage->parent = $temporaryRootParent;
		$bool = $rootPage->save();
		// set notice for root page reparented temporarily
		$this->setFormattedMigrationNotice('pages_temporary_reparent', $bool, $rootPage->path);
	}


	private function actionMigrateRootPage() {

		// NOTE run after ProcessWire Commerce has been installed in order to get its Process Page!
		// NOTE at this point, this has been moved to a temporary parent
		// in order to circumvent the 'shop' name issue, i.e. needed by both Padloper and PW Commerce
		// NOTE also that at this point, template 'padloper' has been renamed to 'pwcommerce'
		// the page name and title remain intact; we amend below
		$rootPage = $this->getPWCommerceRootPageFromTemporaryRootParent();
		$rootParent = $this->getPWCommerceProcessPage();
		
		
		$rootPage->of(false);
		// reparent it
		$rootPage->parent = $rootParent;
		// change title and name
		$rootPage->title = 'PWCommerce';
		$rootPage->name = self::PWCOMMERCE_ROOT_PAGE_NAME;
		$bool = $rootPage->save();
		// set notice for root page reparented permanently
		$this->setFormattedMigrationNotice('pages', $bool, $rootPage->path);
	}

	private function actionMigrateCustomerRole() {
		$customerRole = $this->getPadloperCustomerRole();
		$padloperCustomerRoleName = self::PADLOPER_CUSTOMER_ROLE_NAME;
		$bool = false;
		
		if (!wireInstanceOf($customerRole, 'NullPage')) {
			$customerRole->of(false);
			$customerRole->name = self::PWCOMMERCE_CUSTOMER_ROLE_NAME;
			$bool = $customerRole->save();
			
			// set notice customer role renamed
			$this->setFormattedMigrationNotice('roles', $bool, $customerRole->name);
		} else {
			
			$message  = "(" .
				$padloperCustomerRoleName . " " .
				$this->_('not found') .
				")";
			// set notice customer role not found
			$this->setFormattedMigrationNotice('roles', $bool, $message);
		}
	}

	private function actionMigrateUninstallPadloperModules() {

		$padloperModulesNames = $this->getUninstallPadloperModulesNames();
		

		foreach ($padloperModulesNames as $padloperModuleName) {
			$bool = false;
			try {
				// UNINSTALL MODULE
				$bool = $this->actionMigrateUninstallModule($padloperModuleName);
				// set notice for each module name uninstalled
				$this->setFormattedMigrationNotice('uninstall_module', $bool, $padloperModuleName);
			} catch (\Throwable $th) {
				//throw $th;
				$message = $th->getMessage();
				$message .= " ($padloperModuleName)";
				$this->setFormattedMigrationNotice('uninstall_module', $bool, $message);
			}
		}
	}

	private function actionMigrateUninstallPadloperCustomFields() {

		// NOTE - we get them from tracked names
		// this is because we cannot get them from fields since tyypes have changed
		// e.g. 'padloper_customer' is now 'pwcommerce_customer' of type FieldtypePWCommerceCustomer
		$padloperCustomFields = $this->installedPadloperCustomerFieldsNames;
		

		/** @var Field $padloperCustomField */
		foreach ($padloperCustomFields as $padloperCustomFieldTypeClass) {
			// TODO CONFIRM THIS UNINSTALL ITS INPUTFIELD AS WELL?
			$bool = $this->actionMigrateUninstallModule($padloperCustomFieldTypeClass);
			// set notice for each custom module name uninstalled
			$this->setFormattedMigrationNotice('uninstall_module', $bool, $padloperCustomFieldTypeClass);
		}
	}

	private function actionMigrateInstallPWCommerceModules() {
		$pwcommerceModulesNames = $this->getInstallPWCommerceModulesNames();
		
		/** @var Modules $modules */
		$modules = $this->wire('modules');
		foreach ($pwcommerceModulesNames as $pwcommerceModuleName) {
			$bool = false;
			try {
				// INSTALL MODULE
				$module = $this->actionMigrateInstallModule($pwcommerceModuleName);
				$bool = !empty($module);
				
				
				// set notice for each module name installed
				$this->setFormattedMigrationNotice('install_module', $bool, $pwcommerceModuleName);
				// TODO testing why dependent modules reported as not installed but actually installed! i.e. PwCommerce and PwCommerceHooks
				$modules->refresh();
			} catch (\Throwable $th) {
				//throw $th;
				$bool = false;
				$message = $th->getMessage();
				$message .= " ($pwcommerceModuleName)";
				$this->setFormattedMigrationNotice('install_module', $bool, $message);
				
				
			}
		}
	}


	private function actionMigrateInstallModule($class) {
		
		/** @var Modules $modules */
		$modules = $this->wire('modules');
		$module = $modules->install($class);
		return $module;
	}

	private function actionMigrateUninstallModule($class) {
		
		/** @var Modules $modules */
		$modules = $this->wire('modules');
		$isUninstalled = $modules->uninstall($class);
		return $isUninstalled;
	}

	private function actionMigrateExportPadloperInstallSettings() {
		// NOTE THIS SAVES TO CACHE
		$installConfigs = $this->getPadloperInstallSettings();
		
		$importInstallConfigs = [];
		foreach ($installConfigs as $key => $value) {
			// RENAME as needed
			// TODO not really needed, no?
			$renamedKey = str_replace("padloper", "pwcommerce", $key);
			$importInstallConfigs[$renamedKey] = $value;
		}
		
		// SAVE TO CACHE
		$bool = $this->cacheExportedPadloperInstallSettings($importInstallConfigs);
		// set notice for cache of install settings saved
		$this->setFormattedMigrationNotice('install_settings_cache', $bool);
	}


	private function cacheExportedPadloperInstallSettings($data) {
		$cacheName = self::PWCOMMERCE_IMPORTED_INSTALL_SETTINGS_CACHE_NAME;
		$bool = $this->actionMigrateSaveCache($cacheName, $data);
		return $bool;
	}

	private function actionMigrateSaveCache($cacheName, $data) {
		/** @var WireCache $cache */
		$cache = $this->wire('cache');
		$bool = $cache->save($cacheName, $data);
		return $bool;
	}



	private function actionMigrateImportInstallSettings() {
		// NOTE THIS SAVES FROM CACHED VALUES
		// NOTE value were already prepared for pwcommerce
		$importedInstallSettings = $this->getCachedExportedPadloperInstallSettings();
		// save them
		$bool = $this->savePWCommerceInstallSettings($importedInstallSettings);
		// set notice for process module settings saved/imported
		$this->setFormattedMigrationNotice('install_settings', $bool);
	}

	private function savePWCommerceInstallSettings($data) {
		/** @var Modules $modules */
		$modules = $this->wire('modules');
		$bool = $modules->saveConfig(self::PWCOMMERCE_PROCESS_MODULE, $data);
		return $bool;
	}

	private function actionMigrateCleanup() {
		// NOTE - we will cache notices before this method is called
		// we'll retrieve them in 'finished-migration' page

		// ==============
		// a. clear saved cache with Padloper Install Configs/Settings.
		/** @var WireCache $cache */
		$cache = $this->wire('cache');
		$bool = $cache->delete(self::PWCOMMERCE_IMPORTED_INSTALL_SETTINGS_CACHE_NAME);
		// set notice for cache of install settings deleted
		$this->setFormattedMigrationNotice('install_settings_delete_cache', $bool);

		// b. remove migration session.
		$this->removeMigrationSession();
		$bool = $this->getMigrationSession();
		// set notice for migration session removed
		$this->setFormattedMigrationNotice('session', $bool);

		// ---------
		// REDIRECT TO FINISHED
		$redirectURL = $this->page->url . "finished-migration/";
		$this->session->redirect($redirectURL);
	}


	private function actionCacheMigrationNotices() {
		$cacheName = self::PWCOMMERCE_MIGRATION_NOTICES_CACHE_NAME;
		$data = $this->migrationNotices;
		$bool = $this->actionMigrateSaveCache($cacheName, $data);
		// set notice for cache of migration notices saved
		$this->setFormattedMigrationNotice('migration_notices_cache', $bool);
		return $bool;
	}


	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CACHE  ~~~~~~~~~~~~~~~~~~

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FORM HANDLERS  ~~~~~~~~~~~~~~~~~~

	private function handleMigrationCancel() {
		// remove migration session
		$this->removeMigrationSession();
		// show warning
		$warning = $this->_('Migration session cancelled');
		$this->warning($warning);
		// redirect to home
		$this->session->redirect($this->page->url);
	}

	private function handleMigrationRun() {
		// RUN ACTION MIGRATION
		$this->actionRunMigration();
	}


	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ INSTALL  ~~~~~~~~~~~~~~~~~~

	public function ___install() {

		// check if there is another page in admin with the name 'shop'. If so, abort installation
		if ($this->installerOurModulePageAlreadyExists()) {
			throw new WireException($this->_("Process PWCommerce: Installation aborted. A page with the name 'shop' already exists. This module needs that name. Please fix this then retry."));
		}

		// PWCOMMERCE PROCESS MODULE ADMIN PAGE
		// create the page for this module (ProcessMigratePadloperToPWCommerce)
		// it needs to use the template admin and it needs to have this module as its process
		$page = new Page();
		$page->template = 'admin';
		$page->parent = $this->wire('pages')->get($this->wire('config')->adminRootPageID);
		$page->title = self::PAGE_TITLE;
		$page->name = self::PAGE_NAME;
		$page->process = $this;
		$page->save();
		// -------------



		// -------
		// tell the user we created the page for this module
		$this->message("Process MigratePadloperToPWCommerce: Created page {$page->path}");
	}

	public function ___uninstall() {
		// find and delete the page we installed, locating it by the process field (which has the module ID)
		// it would probably be sufficient just to locate by name, but this is just to be extra sure.
		$moduleID = $this->wire('modules')->getModuleID($this);
		$page = $this->wire('pages')->get("template=admin, process=$moduleID, name=" . self::PAGE_NAME);
		// $page = $this->wire('pages')->get('template=admin, name='.self::PAGE_NAME);
		if ($page->id) {
			// if we found the page, let the user know and delete it
			$this->message($this->_('Process MigratePadloperToPWCommerce: Deleted page ') . $page->path);
			// @note: delete any child pages as well
			$this->wire('pages')->delete($page, true);
		}
	}

	private function installerOurModulePageAlreadyExists() {
		$isPageExist = false;
		// check if our process module's page already exists in Admin
		$parent = $this->wire('pages')->get($this->wire('config')->adminRootPageID);
		$page = $this->wire('pages')->get("parent=$parent, template=admin, include=all, name=" . self::PAGE_NAME);
		if ($page->id && $page->id > 0) {
			$isPageExist = true;
		}

		return $isPageExist;
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DEBUG  ~~~~~~~~~~~~~~~~~~

	private function _debug() {
		// TEST GET PADLOPER PROCESS PAGE
		// $processPadloperShopPage = $this->getProcessPadloperShopPage();
		

		// TEST GET PADLOPER SHOP ROOT PAGE
		// $padloperRootPage = $this->getPadloperRootPage();
		

		// TEST GET PADLOPER TEMPLATES TO RENAME
		// $padloperTemplates = $this->getPadloperTemplates();
		

		// TEST RENAME PADLOPER TEMPLATES
		// $this->actionMigrateTemplates();

		// TEST GET PADLOPER FIELDS TO RENAME
		// $padloperFields = $this->getPadloperFields();
		

		// TEST RENAME PADLOPER FIELDS
		// $this->actionMigrateFields();

		// TEST GET PROCESS PADLOPER INSTALL SETTINGS TO IMPORT
		// $installConfigs = $this->getPadloperInstallSettings();
		


		// TODO ALSO NEED TO CHANGE THE FIELDS TYPES IF THEY ARE CUSTOM PADLOPER ONES!
		// TODO NEEDS TO BE DONE AFTER PWCOMMERCE IS INSTALLED + ITS FIELDS ARE INSTALLED
		// TODO BUT HOW WILL WE KNOW THE FIELDS TO INSTALL? MAYBE THEY SHOULD MANUALLY INSTALL PW COMMERCE? I.E. INCLUDING STAGE 2?
		// WE CAN CHECK FIELDS TO INSTALL USING CONFIGS BUT THAT IS TEDIOUS?!


		// TEST GET PADLOPER CUSTOM FIELDS
		// $padloperCustomFields = $this->getPadloperCustomFields();
		// $pwcommerceCustomFields = $this->getPWCommerceCustomFields();
		
		


		// TEST CHANGE TYPE OF PADLOPER CUSTOM FIELDS
		// $this->actionMigrateCustomFieldsTypes();


		// TEST IMPORT PROCESS PADLOPER INSTALL SETTINGS
		// $this->actionMigrateImportInstallSettings();

		// TEST GET PADLOPER SITE ASSETS FOLDER TO RENAME
		// $padloperAssetsFolder = $this->getPadloperAssetsFolder();
		

		// TEST RENAME PADLOPER SITE ASSETS FOLDER
		// $this->actionMigratePadloperAssetsFolder();


		// TEST GET PADLOPER BACKEND TEMPLATE PARTIALS TO RENAME
		// $backendTemplatePartialsFiles = $this->getPadloperBackendTemplatePartials();
		

		// TEST RENAME PADLOPER BACKEND TEMPLATE PARTIALS
		// $this->actionMigrateBackendTemplatePartials();

		// TEST GET PADLOPER MODULES NAMES TO UNINSTALL
		// $padloperModules = $this->getUninstallPadloperModulesNames();
		

		// TEST UNINSTALL PADLOPER MODULES
		// $this->actionMigrateUninstallPadloperModules();
	}
}
